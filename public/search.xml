<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode-242-Valid Anagram-有效易位串]]></title>
    <url>%2F2020%2F03%2F05%2FLeetCode-242-Valid-Anagram-%E6%9C%89%E6%95%88%E6%98%93%E4%BD%8D%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[242. Valid Anagram Easy Given two strings _s_ and _t_, write a function to determine if _t_ is an anagram of _s_. Example 1: 12Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;Output: true Example 2: 12Input: s = &quot;rat&quot;, t = &quot;car&quot;Output: false Note:You may assume the string contains only lowercase alphabets. Follow up:What if the inputs contain unicode characters? How would you adapt your solution to such case? Solution建立一个 Hash 表来计数，如果字符串中只包含小写字母，可以直接用数组来计数。 1234567891011121314class Solution &#123;public: bool isAnagram(string s, string t) &#123; if(s.length() != t.length()) return false; unordered_map&lt;char,int&gt; count; for(int i=0;i&lt;s.length();i++)&#123; count[s[i]]++; count[t[i]]--; &#125; for(auto x:count) if(x.second) return false; return true; &#125;&#125;; 注意这里利用了 map 的初始化特性，对于语句 count[s[i]];, 如果 count 中没有键 s[i]，将自动插入改键并将相应的值初始化为0。因此 count[s[i]]++; 无需检测 s[i] 的存在性。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>易位串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-257-Binary Tree Paths-二叉树路径]]></title>
    <url>%2F2020%2F03%2F05%2FLeetCode-257-Binary-Tree-Paths-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[257. Binary Tree PathsEasy Given a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: 1234567891011Input: 1 / \2 3 \ 5Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3 Solution递归。需要3个参数：当前节点，当前节点的祖先节点组成的路径（用字符串保存），当前结果集（字符串数组）。 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; res; string ans = ""; visit(root, ans, res); return res; &#125; void visit(TreeNode* p, string ans, vector&lt;string&gt; &amp;res)&#123; if(!p) return; if(!p-&gt;left &amp;&amp; !p-&gt;right)&#123; ans += to_string(p-&gt;val); res.push_back(ans); return; &#125; ans += to_string(p-&gt;val) + "-&gt;"; if(p-&gt;left) visit(p-&gt;left, ans, res); if(p-&gt;right) visit(p-&gt;right, ans, res); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-01-两数之和-Two Sum]]></title>
    <url>%2F2019%2F11%2F22%2FLeetCode-01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-Two-Sum%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-07-整数逆序-Reverse-Integer]]></title>
    <url>%2F2019%2F10%2F16%2FLeetCode-07-%E6%95%B4%E6%95%B0%E9%80%86%E5%BA%8F-Reverse-Integer%2F</url>
    <content type="text"><![CDATA[本题算法层面无需赘述，唯一值得注意的是int溢出的检查，这可能涉及一些具体语言特性相关的知识。对C++而言，以下几个知识点可能有所帮助： 预定义常量：int最大正数INT_MAX，最小负数INT_MIN，其他类型也有类似常量定义 整数类型：一般而言 short，int，long long 分别为2字节，4字节，8字节整数，值得注意的是 long 一般与 int 相同，这一特殊情形是历史原因造成的。int，long 等类型的实际宽度与机器字长、编译器等因素均有关 代码中数字常量的默认类型：对于正数，按照 int $\rightarrow$ unsigned int $\rightarrow$ long long $\rightarrow$ unsigned long long 匹配；对于浮点数和科学计数法，一律为double型。超出最大表示范围的数字常量会报错 本题代码如下： 1234567891011121314class Solution &#123;public: int reverse(int x) &#123; long long result = 0; while (x != 0) &#123; result = result * static_cast&lt;long long&gt;(10) + static_cast&lt;long long&gt;(x % 10); x /= 10; &#125; if (result &gt; INT_MAX || result &lt; INT_MIN) return 0; else return static_cast&lt;int&gt;(result); &#125;&#125;; 循环次数为十进制整数的位数，因此复杂度为$O(\mathrm{log}_{10} n)$ 。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>整数逆序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-06-之字形转换-ZigZag-Conversion]]></title>
    <url>%2F2019%2F10%2F15%2FLeetCode-06-%E4%B9%8B%E5%AD%97%E5%BD%A2%E8%BD%AC%E6%8D%A2-ZigZag-Conversion%2F</url>
    <content type="text"><![CDATA[写几个例子找规律即可，不难发现转换后第一行和最后一行的字符在原串中的索引构成等差数列，中间行的字符在原串中的索引构成“双“等差数列（$a_1=a_0+d_1, a_2=a_1+d_2, a_3=a_2+d_1, \cdots$），找出三个公差即可。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: string convert(string s, int numRows) &#123; int L = s.length(); //行数为1或者行数不小于s的长度返回s即可 if (numRows == 1 || numRows &gt;= L) return s; string szz = ""; //保存结果 for (int i = 1; i &lt;= numRows; i++) &#123; //处理第一行和最后一行，等差数列 if(i == 1 || i == numRows) &#123; int j = i - 1; while(j &lt; L) &#123; szz += s[j]; j += 2 * (numRows - 1); &#125; &#125; //中间的行，“双”等差数列 else &#123; int j = i - 1; while (j &lt; L) &#123; szz += s[j]; j += 2 * (numRows - i); if (j &lt; L) &#123; szz += s[j]; j += 2 * (i - 1); &#125; &#125; &#125; &#125; return szz; &#125;&#125;; 每次操作均能确定目标串的一个字符，时间复杂度为$O(n)$。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>之字形转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-05.最长回文子串(LPS)]]></title>
    <url>%2F2019%2F10%2F09%2FLeetCode-05-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-LPS%2F</url>
    <content type="text"><![CDATA[先找出每个对称中心对应的LPS的长度，然后取最长的即可。注意奇数长度的串和偶数长度的串情况是不一样的，对称中心可以是元素本身也可以是元素间的间隙。若将所有间隙全部填充上同一字符（不能是串中出现的字符），便可统一为奇数情形进行处理，如 “ada” 变为 “a#d#a” ， “adaa” 变为 “a#d#a#a” 。 代码如下，这里不进行填充而是分情况讨论: 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string longestPalindrome(string s) &#123; int L = s.length(); int k = 0, len = 0; for (int i = 0; i &lt; L; i++) &#123; //考虑s[i]为对称中心 int pr1 = 1; //回文半径(包含中心) while (i - pr1 &gt;= 0 &amp;&amp; i + pr1 &lt; L &amp;&amp; s[i - pr1] == s[i + pr1]) pr1++; //考虑s[i]与s[i+1]之间的空隙为对称中心 int pr2 = 0; //回文半径 while (i - pr2 &gt;= 0 &amp;&amp; i + pr2 + 1 &lt; L &amp;&amp; s[i - pr2] == s[i + pr2 + 1]) pr2++; int len1 = 2 * (pr1 - 1) + 1; int len2 = 2 * pr2; if (max(len1, len2) &gt; len) &#123; if (len1 &gt; len2) &#123; k = i - pr1 + 1; len = len1; &#125; else &#123; k = i - pr2 + 1; len = len2; &#125; &#125; &#125; return s.substr(k, len); &#125;&#125;; 该算法时间复杂度显然为$O(n^2)$，提交LeetCode发现AC了。 实际上，有一种Manacher算法能够在$O(n)$时间内找到LPS，不过这是一种非通用算法，即该算法只能应用于解决LPS问题，因而实用价值不高。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>LPS</tag>
      </tags>
  </entry>
</search>
