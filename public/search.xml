<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode-220-Contains Duplicate III]]></title>
    <url>%2F2020%2F03%2F25%2FLeetCode-220-Contains-Duplicate-III%2F</url>
    <content type="text"><![CDATA[220. Contains Duplicate III Medium DescriptionGo to LeetCode Solution 1滑动窗口法。维护一个宽度为 k 的滑动窗口 win ，显然窗口内的元素两两间的索引之差不会超过 k ，难点在于如何检查窗口内是否存在绝对差值不超过 t 的两个元素。 滑动窗口每插入一个新的元素 x ，就要检查窗口中是否已经存在与 x 的绝对差值不超过的 t 的元素。换句话说，要检查窗口内是否存在 [x-t, x+t] 区间内的元素。 为了做到这一点，可利用一个升序表存储滑动窗口，例如C++ STL 中的 set 容器；要检查一个升序表中是否存在包含于特定区间 [left, right] 中的元素，可利用二分查找的方法在 $O(\log n)$ 时间内完成。具体做法是：在升序表中二分查找区间的左边界 left ，返回第一个大于等于 left 的元素 ，即表中最小的大于等于 left 的元素，然后检查该元素是否小于等于区间的右边界 right ；如果表中所有元素都小于 left ，则查找失败，不存在目标区间内的元素。 C++ STL set 容器的 lower_bound 方法实现了查找有序表中第一个大于等于目标元素的功能，直接调用即可。 12345678910111213141516class Solution &#123;public: bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123; set&lt;long long&gt; win; long long kl = k, tl = t; for(int i=0;i&lt;nums.size();i++)&#123; long long x = nums[i]; if(i&gt;k) win.erase(nums[i-k-1]); //窗口满，每滑动一步删除第一个元素 auto it = win.lower_bound(x-tl); if(it != win.end() &amp;&amp; *it &lt;= x+tl) return true; win.insert(x); &#125; return false; &#125;&#125;; 上面的代码逻辑上虽然没问题，但涉及到两个 int 型变量的加减时可能导致溢出，在 LeetCode 上不能 AC，简单修改后防止 int 溢出的代码如下： 12345678910111213141516class Solution &#123;public: bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123; set&lt;long long&gt; win; long long kl = k, tl = t; for(int i=0;i&lt;nums.size();i++)&#123; long long x = nums[i]; if(i&gt;k) win.erase(nums[i-k-1]); auto it = win.lower_bound(x-tl); if(it != win.end() &amp;&amp; *it &lt;= x+tl) return true; win.insert(x); &#125; return false; &#125;&#125;; 此方法的时间复杂度为 $O(n\log k)$ ，空间复杂度为 $O(k)$ 。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-219-Contains Duplicate II]]></title>
    <url>%2F2020%2F03%2F25%2FLeetCode-219-Contains-Duplicate-II%2F</url>
    <content type="text"><![CDATA[219. Contains Duplicate II Easy DescriptionGo to LeetCode Solution滑动窗口法。维护一个长为 k 的滑动窗口，显然窗口内的元素都满足两两之间的索引相差不超过 k ，从而只需要检查窗口内是否有重复元素即可。为了方便检查是否有重复元素，可用一个哈希表存储该滑动窗口。 12345678910111213class Solution &#123;public: bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_set&lt;int&gt; hash; for(int i=0;i&lt;nums.size();i++)&#123; if(i &gt; k) hash.erase(nums[i-k-1]); if(!hash.insert(nums[i]).second) return true; &#125; return false; &#125;&#125;; 时间 $O(n)$ ，空间 $O(k)$ 。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-217-Contains Duplicate]]></title>
    <url>%2F2020%2F03%2F25%2FLeetCode-217-Contains-Duplicate%2F</url>
    <content type="text"><![CDATA[217. Contains Duplicate Easy DescriptionGo to LeetCode Solution 1先排序，然后检查相邻的两个元素有没有相等的情形。 123456789101112class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return false; sort(nums.begin(),nums.end()); for(int i=0;i&lt;nums.size()-1;i++)&#123; if(nums[i] == nums[i+1]) return true; &#125; return false; &#125;&#125;; 时间 $O(n\log n)$ ，空间 $O(1)$ 。 Solution 2遍历的同时用一个哈希表存储已有的元素，每访问一个元素检查是否已在表中。 123456789class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; hash; for(auto x:nums) if(!hash.insert(x).second) return true; return false; &#125;&#125;; 时间 $O(n)$ ，空间 $O(n)$ 。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-222-Count Complete Tree Nodes]]></title>
    <url>%2F2020%2F03%2F24%2FLeetCode-222-Count-Complete-Tree-Nodes%2F</url>
    <content type="text"><![CDATA[222. Count Complete Tree Nodes Medium DescriptionGo to LeetCode Solution如果是一般的二叉树，一个简单的递归即可： 12345678910111213141516/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int countNodes(TreeNode* root) &#123; if(!root) return 0; return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1; &#125;&#125;; 时间复杂度为 $O(n)$ ，空间复杂度为 $O(\log n)$ 。 题目给了完全二叉树的条件，就要充分利用完全二叉树的性质。如果该完全二叉树是满二叉树，则其节点数为 $2^h-1$ ，其中 $h$ 为树的高度。如果不是满二叉树，那么它的左孩子和右孩子一定都是完全二叉树并且至少有一个是满二叉树，可由此递归求得节点总数。 判断一颗完全二叉树是否是满二叉树，只需要分别沿最左边和最右边的路径走到底，看路径长度是否相等即可，该操作的时间复杂度为 $O(\log n)$ ，同时也求出了树高 $h$ 。 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int countNodes(TreeNode* root) &#123; if(!root) return 0; int hl = 0, hr = 0; TreeNode* p = root; while(p)&#123; p = p-&gt;left; hl++; &#125; p = root; while(p)&#123; p = p-&gt;right; hr++; &#125; if(hl == hr) return pow(2, hl) - 1; else return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right); &#125;&#125;; 该算法的时间复杂度比较难以分析。由于节点数为 $n$ 的完全二叉树的两个孩子一定至少有一个是满二叉树，对这个孩子可在 $O(\log n)$ 时间内判定并求解；对于另一个孩子进行递归处理，产生了一个节点数至多为 $n/2$ 的子问题，故对于时间复杂度有如下的递推关系： \begin{aligned} O(n)&=O(n/2) + c_1 \log n \\ &=O(n/4) + c_1 \log n + c_2 \log n \\ &=\cdots \\ &=O(1)+c_1\log n + c_2\log n + \cdots \\ &=O(\log^2 n) \end{aligned}空间复杂度仍为 $O(\log n)$ 。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-221-Maximal Square]]></title>
    <url>%2F2020%2F03%2F24%2FLeetCode-221-Maximal-Square%2F</url>
    <content type="text"><![CDATA[221. Maximal Square Medium DescriptionGo to LeetCode Solution 1DP。用 $dp(i,j)$ 表示以元素 $(i,j)$ 为右下顶点的全1最大正方形的边长，可得如下的状态转移方程 dp(i,j)=\min\left\{dp(i-1,j-1),dp(i-1,j),dp(i,j-1)\right\}+1对于第一行和第一列中的元素，对应的最大边长只能为 0 或 1，根据矩阵 matrix 的第一行和第一列初始化 dp 数组即可。 注意小坑：给的 matrix 中存储的是字符 &#39;0&#39; 和 &#39;1&#39; 而不是数字。 1234567891011121314151617181920class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty()) return 0; int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); int res = 0; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(!i || !j) dp[i][j] = matrix[i][j] - '0'; else if(matrix[i][j] == '1')&#123; dp[i][j] = min(dp[i-1][j-1], min(dp[i][j-1], dp[i-1][j])) + 1; &#125; res = max(res, dp[i][j]); &#125; &#125; return res*res; &#125;&#125;; 时间复杂度和空间复杂度均为 $O(mn)$ 。 Solution 2注意到方法1中的状态转移方程中需要得到当前元素的左边、上方、以及左上方三个邻居的最小值，而循环又是逐行从左向右进行遍历的，处理新的一行时只需要上一行的结果和当前行已有的结果，对于更前面的行的结果是没必要保存的。因此，只需要两个长为 n 的数组 last_row 和 this_row 分别保存上一行的结果和当前行的结果，当新的一行开始时，把 this_row 的值赋给 last_row 。 1234567891011121314151617181920212223242526class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty()) return 0; int m = matrix.size(), n = matrix[0].size(); vector&lt;int&gt; last_row(n, 0), this_row(n, 0); int res = 0; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(!i) this_row[j] = matrix[i][j] - '0'; else if(!j)&#123; last_row.assign(this_row.begin(), this_row.end()); this_row[j] = matrix[i][j] - '0'; &#125; else if(matrix[i][j] == '1')&#123; this_row[j] = min(this_row[j-1], min(last_row[j-1], last_row[j])) + 1; &#125; else this_row[j] = 0; res = max(res, this_row[j]); &#125; &#125; return res*res; &#125;&#125;; 此方法时间复杂度为 $O(mn)$ ，空间复杂度为 $O(n)$ 。 Solution 3显然方法2中仍然多保存了不必要的元素。 处理当前元素 $(i,j)$ 时，上一行中 $(i-1,j-1)$ 之前的元素也是没必要保存的，这部分空间恰好可以用来保存当前行已经得到的结果，这样只用一个长为 n 的数组 row 就可以完成任务。 当然由于上一行需要保存的元素为从 $dp(i-1,j-1)$ 到 $dp(i-1,n-1)$ ，共 $n-j+1$ 个；当前行已有的结果为从 $dp(i,0)$ 到 $dp(i,j-1)$ ，共 $j$ 个，因此共 $n+1$ 个元素需要保存，多出一个。于是额外用一个变量 left_up 来保存当前元素左上方的邻居。 这样来看， row[0] 到 row[j-1] 保存的是当前行的前一段 $dp(i,0)$ 到 $dp(i,j-1)$ ， row[j] 到 row[n-1] 保存的是上一行的后一段 $dp(i-1,j)$ 到 $dp(i-1,n-1)$ ，剩一个 $dp(i-1,j-1)$ 用 left_up 来保存。 12345678910111213141516171819202122class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty()) return 0; int m = matrix.size(), n = matrix[0].size(), left_up = 0, res = 0; vector&lt;int&gt; row(n, 0); for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; int temp = row[j]; if(!i || !j || matrix[i][j] == '0')&#123; row[j] = matrix[i][j] - '0'; &#125; else&#123; row[j] = min(left_up, min(row[j-1],row[j])) + 1; &#125; res = max(res, row[j]); left_up = temp; &#125; &#125; return res*res; &#125;&#125;; 此方法时间复杂度为 $O(mn)$ ，空间复杂度也为 $O(n)$ ，但与方法2相比常数因子更小，少用了一个长为 n 的数组。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-223-Rectangle Area]]></title>
    <url>%2F2020%2F03%2F18%2FLeetCode-223-Rectangle-Area%2F</url>
    <content type="text"><![CDATA[223. Rectangle Area Medium DescriptionGo to LeetCode Solution基本思路是两个矩形的面积之和减去相交部分的面积，关键在于如何求相交部分的面积。分不同位置的相交情形进行讨论可能是最直接的办法，但情况太多，太复杂。实际上相交部分的四条边的坐标都很容易求得，比如相交部分上边界的纵坐标一定是两个矩形的上边界的纵坐标中较小的一个，以此类推。当然，还需要考虑是否相交。 12345678class Solution &#123;public: int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; int x = max(A,E) &lt; min(C,G) ? min(C,G) - max(A,E) : 0; int y = max(B,F) &lt; min(D,H) ? min(D,H) - max(B,F) : 0; return (C-A)*(D-B) - x*y + (G-E)*(H-F); //此处减法必须放到中间，因为先算加法可能会溢出 &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Weekly Contest 180]]></title>
    <url>%2F2020%2F03%2F17%2FLeetCode-Weekly-Contest-180%2F</url>
    <content type="text"><![CDATA[1374. Generate a String With Characters That Have Odd Counts Easy DescriptionGo to LeetCode Solution对于每一行，先找到最小元 elem ，然后检查它是不是所在列的最大元。 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; luckyNumbers (vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; res; for(int i=0;i&lt;matrix.size();i++)&#123; int elem = INT_MAX, index = 0; for(int j=0;j&lt;matrix[0].size();j++)&#123; if(matrix[i][j]&lt;elem)&#123; elem = matrix[i][j]; index = j; &#125; &#125; int k=0; for(;k&lt;matrix.size();k++)&#123; if(matrix[k][index]&gt;elem) break; &#125; if(k == matrix.size()) res.push_back(elem); &#125; return res; &#125;&#125;; 时间复杂度为 $O(mn)$ 。 1381. Design a Stack With Increment Operation Medium DescriptionGo to LeetCode Solution维护一个数组即可。 123456789101112131415161718192021222324252627282930313233343536class CustomStack &#123; vector&lt;int&gt; data; int top; int max_size;public: CustomStack(int maxSize) &#123; top = 0; max_size = maxSize; data.resize(max_size); &#125; void push(int x) &#123; if(top &lt; max_size) data[top++] = x; &#125; int pop() &#123; if(top&gt;0) return data[--top]; else return -1; &#125; void increment(int k, int val) &#123; for(int i=0;i&lt;k &amp;&amp; i&lt;top;i++) data[i] += val; &#125;&#125;;/** * Your CustomStack object will be instantiated and called as such: * CustomStack* obj = new CustomStack(maxSize); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * obj-&gt;increment(k,val); */ 1382. Balance a Binary Search Tree Medium DescriptionGo to LeetCode Solution 1考虑到一个有序数组转化为平衡二叉树是容易的（首先将中间的元素作为根节点，再利用分治法递归处理两边即可），而二叉排序树的中序遍历序列就是一个升序数组，因此先对 BST 进行中序遍历得到升序数组，再根据有序数组建立 BBST 即可。注意数组直接存储节点指针比较省空间。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* balanceBST(TreeNode* root)&#123; vector&lt;TreeNode*&gt; seq; getInOrderSeq(root, seq); return getBalancedBST(seq, 0, seq.size()-1); &#125; void getInOrderSeq(TreeNode* t, vector&lt;TreeNode*&gt; &amp;seq)&#123; if(!t) return; getInOrderSeq(t-&gt;left, seq); seq.push_back(t); getInOrderSeq(t-&gt;right, seq); &#125; TreeNode* getBalancedBST(vector&lt;TreeNode*&gt; &amp;seq, int left, int right)&#123; if(left &gt; right) return NULL; int mid = left + ((right - left) &gt;&gt; 1); TreeNode *res = seq[mid]; res-&gt;left = getBalancedBST(seq, left, mid - 1); res-&gt;right = getBalancedBST(seq, mid + 1, right); return res; &#125;&#125;; 此方法时间复杂度为和空间复杂度均为 $O(n)$ 。 Solution 2实际上，有所谓 DSW 算法能够在 $O(n)$ 时间和 $O(1)$ 空间内对二叉排序树进行平衡化，详见下列资料： Day–Stout–Warren algorithm - Wikipedia 二叉查找树的平衡（DSW算法） 1383. Maximum Performance of a Team Hard DescriptionGo to LeetCode Solution（待补充…）]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-229-Majority Element II]]></title>
    <url>%2F2020%2F03%2F17%2FLeetCode-229-Majority-Element-II%2F</url>
    <content type="text"><![CDATA[229. Majority Element II Medium DescriptionGo to LeetCode SolutionBoyer-Moore 多数投票算法的扩展。 Boyer-Moore Majority Vote algorithm 是一个利用 $O(n)$ 时间和 $O(1)$ 空间寻找长度为 $n$ 的数组中出现次数超过 $\lfloor n/2 \rfloor$ 的元素的算法，其流程如下： 变量 candidate 表示当前候选元素，初始化为任意值，变量 count 表示当前计数，初始化为0，从第一个元素开始扫描数组： 若当前元素与 candidate 相同，count 加1； 若当前元素与 candidate 不同且 count &gt; 0 ，count 减1； 若当前元素与 candidate 不同且 count = 0 ，当前元素成为新的 candidate ，count 重置为1； 最终 candidate 的值即为所求。 该算法的原理在于，对于任意的 candidate ，如果扫描到的元素和 candidate 不相等，就在数组中同时划去一个 candidate 和当前元素。count = 0 表示当前的 candidate 都被划去了，因此指定新的 candidate 。由于目标元素 $x$ 在数组中出现的次数超过了一半，那么其它元素出现的次数必定小于一半。这样不断划去成对的不相同的元素之后，最终剩下的一定是 $x$ 。 注意上述算法需要保证给定的数组中一定存在目标元素，如果没有这一保证，只需要在求出最后的 candidate 后再检查一遍它出现的额次数即可，这一操作不增加复杂度。 本题将 $\lfloor n/2 \rfloor$ 改成了 $\lfloor n/3 \rfloor$ ，解法是一样的。只需要维护两个候选元素 cdt1 ，cdt2 和它们各自的计数 cnt1 ，cnt2 ，若当前扫描的元素和其中任一个相同，对应的计数加1；若都不同则将当前元素和任一个候选元素同时划去（对应计数减一）；若某个候选元素被全部划去（计数为0）则将当前元素置为新的候选元素。最终剩下的两个候选元素就是可能的目标，若题目并未保证存在目标元素则再检验一下两个元素出现的次数。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; int cdt1 = 0, cdt2 = 0, cnt1 = 0, cnt2 = 0; for(auto x:nums)&#123; if(x == cdt1) cnt1++; else if(x == cdt2) cnt2++; else if(!cnt1)&#123; cdt1 = x; cnt1 = 1; &#125; else if(!cnt2)&#123; cdt2 = x; cnt2 = 1; &#125; else&#123; cnt1--; cnt2--; &#125; &#125; cnt1 = 0; cnt2 = 0; for(auto x:nums)&#123; if(x == cdt1) cnt1++; else if(x == cdt2) cnt2++; &#125; vector&lt;int&gt; res; if(cnt1 &gt; nums.size()/3) res.push_back(cdt1); if(cnt2 &gt; nums.size()/3) res.push_back(cdt2); return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-228-Summary Ranges]]></title>
    <url>%2F2020%2F03%2F17%2FLeetCode-228-Summary-Ranges%2F</url>
    <content type="text"><![CDATA[228. Summary Ranges Medium DescriptionGo to LeetCode Solution用两个指针 start 和 end 分别标识一段的起始元素和终止元素即可，注意区分出只含一个数的情形，即判断 start == end 。 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0) return &#123;&#125;; vector&lt;string&gt; res; int start = nums[0], end = start; for(int i=1;i&lt;nums.size();i++)&#123; if(nums[i] != nums[i-1]+1)&#123; end = nums[i-1]; if(start != end)&#123; string temp = to_string(start) + "-&gt;" + to_string(end); res.push_back(temp); &#125; else res.push_back(to_string(start)); start = nums[i]; &#125; &#125; end = nums[nums.size()-1]; if(start != end)&#123; string temp = to_string(start) + "-&gt;" + to_string(end); res.push_back(temp); &#125; else res.push_back(to_string(start)); return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-227-Basic Calculator II]]></title>
    <url>%2F2020%2F03%2F16%2FLeetCode-227-Basic-Calculator-II%2F</url>
    <content type="text"><![CDATA[227. Basic Calculator II Medium DescriptionGo to LeetCode Solution此类表达式实际上就是若干单项式的和，因此只要求出每一项的值然后加到结果变量中即可。 利用字符串流 stringstream 来处理表达式串相对比较方便，在输入的最前面补一个 + 号使得输入的串统一为符号与数字相间隔的模式，然后每次读入一个符号 op 和一个数字 num 。 用 term 表示当前项的值，每次循环读入一个运算符 op 及其后面的数 num ，若 op = + 或 - ，表示新的一项开始了，前一项计算完成，因此将 term 加到结果中，并重置 term 的值为新一项的第一个数 num 或者 -num (视 op 的值而定)；若 op = * 或 / ，则继续计算当前项，更新 term 。 注意最后一次循环只计算完成了最后一项的值，还需要加到结果中。 1234567891011121314151617181920212223242526class Solution &#123;public: int calculate(string s) &#123; istringstream ss("+" + s); long long res = 0; int term = 0, num = 0; char op; while(ss &gt;&gt; op &gt;&gt; num)&#123; if(op == '+' || op == '-')&#123; res += term; term = op == '+' ? num : - num; &#125; else&#123; term = op == '*' ? term * num : term / num; &#125; &#125; res += term; return res; &#125;&#125;;static int speedup = []()&#123; std::ios::sync_with_stdio(false); cin.tie(NULL); return 0;&#125;();]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-226-Invert Binary Tree]]></title>
    <url>%2F2020%2F03%2F16%2FLeetCode-226-Invert-Binary-Tree%2F</url>
    <content type="text"><![CDATA[226. Invert Binary Tree Easy DescriptionGo to LeetCode Solution递归即可。先交换当前节点的左右孩子，再递归反转左子树，最后递归反转右子树。终止条件为当前节点为空或者当前节点为叶节点。 123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(!root || (!root-&gt;left &amp;&amp; !root-&gt;right)) return root; TreeNode *temp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = temp; invertTree(root-&gt;left); invertTree(root-&gt;right); return root; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-225-Implement Stack using Queues]]></title>
    <url>%2F2020%2F03%2F16%2FLeetCode-225-Implement-Stack-using-Queues%2F</url>
    <content type="text"><![CDATA[225. Implement Stack using Queues Easy DescriptionGo to LeetCode Solution用一个队列的队头表示栈顶，队尾表示栈底。第 k 个元素入栈的时候先将其从队尾入队，然后将前面的 k-1 个元素依次从队头出队并从队尾入队。由于队列是 FIFO 的数据结构，这样能够保持先入栈的元素始终更靠近队头，也即更靠近栈顶，恰好符合栈的定义。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class MyStack &#123; queue&lt;int&gt; q;public: /** Initialize your data structure here. */ MyStack() &#123; &#125; /** Push element x onto stack. */ void push(int x) &#123; q.push(x); int k = q.size() - 1; while(k--)&#123; q.push(q.front()); q.pop(); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ int pop() &#123; int res = top(); q.pop(); return res; &#125; /** Get the top element. */ int top() &#123; return q.front(); &#125; /** Returns whether the stack is empty. */ bool empty() &#123; return q.empty(); &#125;&#125;;/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */ 此方法时间复杂度为 push $O(n)$ ，pop/top/empty $O(1)$ 。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-224-Basic Calculator]]></title>
    <url>%2F2020%2F03%2F15%2FLeetCode-224-Basic-Calculator%2F</url>
    <content type="text"><![CDATA[224. Basic Calculator Hard Implement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces . Example 1: 12Input: &quot;1 + 1&quot;Output: 2 Example 2: 12Input: &quot; 2-1 + 2 &quot;Output: 3 Example 3: 12Input: &quot;(1+(4+5+2)-3)+(6+8)&quot;Output: 23 Note: You may assume that the given expression is always valid. Do not use the eval built-in library function. Solution由于表达式只含加减法，故只需要确定每个数在最终结果中的符号，最后相加即可。对于括号外的数，其最终符号就是数字前面的符号；对于括号里面的数，其最终的符号与数字前面的符号以及所有包含它的括号的符号均相关。 用 1 和 -1 分别表示正负号，考虑最外层括号，设 s 为最外层括号的符号，那么对于这层括号里面的任何一项（包含数字或者括号），设其本来的符号为 t ，则这一项在这层括号去掉后的符号为 s*t 。根据这一规律，便可以逐层求得括号里面的数的最终符号，相当于逐层去括号。 编程实现的核心要点是用一个栈 stk 保存每一层括号成为最外层括号时的符号 。 1234567891011121314151617181920212223class Solution &#123;public: int calculate(string s) &#123; int res = 0, num = 0, sign = 1; stack&lt;int&gt; stk; stk.push(sign); for(auto x:s)&#123; if(x &gt;= '0' &amp;&amp; x &lt;= '9') num = num*10 + (x-'0'); //这个括号必须加，不然先计算前面的加法可能溢出 else if(x == '+' || x == '-')&#123; res += sign*num; sign = stk.top()*(x=='+' ? 1 : -1); num = 0; &#125; else if(x == '(') stk.push(sign); else if(x == ')') stk.pop(); &#125; res += sign*num; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-230-Kth Smallest Element in a BST]]></title>
    <url>%2F2020%2F03%2F11%2FLeetCode-230-Kth-Smallest-Element-in-a-BST%2F</url>
    <content type="text"><![CDATA[230. Kth Smallest Element in a BST Medium Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:You may assume k is always valid, 1 ≤ k ≤ BST’s total elements. Example 1: 1234567Input: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2Output: 1 Example 2: 123456789Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1Output: 3 Follow up:What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine? SolutionBST 的特点是其中序遍历就是递增序列，故利用二叉树非递归形式的中序遍历结合简单计数便可找到所求元素。 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int kthSmallest(TreeNode* root, int k) &#123; TreeNode *p = root; stack&lt;TreeNode*&gt; stk; while(p || !stk.empty())&#123; while(p)&#123; stk.push(p); p = p-&gt;left; &#125; if(!stk.empty())&#123; p = stk.top(); if(!(--k)) return p-&gt;val; stk.pop(); p = p-&gt;right; &#125; &#125; return 0; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-231-Power of Two]]></title>
    <url>%2F2020%2F03%2F11%2FLeetCode-231-Power-of-Two%2F</url>
    <content type="text"><![CDATA[231. Power of Two Easy Given an integer, write a function to determine if it is a power of two. Example 1: 123Input: 1Output: true Explanation: 20 = 1 Example 2: 123Input: 16Output: trueExplanation: 24 = 16 Example 3: 12Input: 218Output: false Solution注意到 2 的幂的特点是其二进制表示中只有一个 1 ，其余数位全部为 0 ，可以用 n &amp; n-1 的技巧来检验这一点： 若 n 是 2 的幂，设其二进制中第 k 位为 1 ，则 n-1 的二进制必然是1 ~ k - 1位均为 1 ，其余位为0 。这样 n &amp; n-1 必为 0 ； 若 n &gt; 0 不是 2 的幂，则其二进制中必然包含至少两个 1 ，设位次最小的两个 1 分别在 k, m 位 (k &lt; m) ，则n-1 的二进制必然是1 ~ k - 1位均为 1，第 k 位为 0 ，第 m 位以及更高位的 1 均保持不变。这样 n &amp; n-1 必不为 0 。 123456class Solution &#123;public: bool isPowerOfTwo(int n) &#123; return n&gt;0 &amp;&amp; !(n&amp;(n-1)); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-232-Implement Queue using Stacks]]></title>
    <url>%2F2020%2F03%2F11%2FLeetCode-232-Implement-Queue-using-Stacks%2F</url>
    <content type="text"><![CDATA[232. Implement Queue using Stacks Easy Implement the following operations of a queue using stacks. push(x) — Push element x to the back of queue. pop() — Removes the element from in front of queue. peek() — Get the front element. empty() — Return whether the queue is empty. Example: 1234567MyQueue queue = new MyQueue();queue.push(1);queue.push(2); queue.peek(); // returns 1queue.pop(); // returns 1queue.empty(); // returns false Notes: You must use _only_ standard operations of a stack — which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). Solution想象两个栈的栈底连在一起，一个作为队尾，一个作为队头。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class MyQueue &#123; stack&lt;int&gt; stk_head; stack&lt;int&gt; stk_tail;public: /** Initialize your data structure here. */ MyQueue() &#123; &#125; /** Push element x to the back of queue. */ void push(int x) &#123; stk_tail.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; if(!empty())&#123; int res = peek(); stk_head.pop(); return res; &#125; else return 0; &#125; /** Get the front element. */ int peek() &#123; if(!stk_head.empty()) return stk_head.top(); else if(!stk_tail.empty())&#123; while(!stk_tail.empty())&#123; int temp = stk_tail.top(); stk_tail.pop(); stk_head.push(temp); &#125; return stk_head.top(); &#125; else return 0; &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return stk_head.empty() &amp;&amp; stk_tail.empty(); &#125;&#125;;/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-233-Number of Digit One]]></title>
    <url>%2F2020%2F03%2F10%2FLeetCode-233-Number-of-Digit-One%2F</url>
    <content type="text"><![CDATA[233. Number of Digit One Hard Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. Example: 123Input: 13Output: 6 Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13. SolutionBroute - Force 将会超时。 显然本题应当从数字 1 在 n 的任一数位上出现的次数分析，找出规律，本质上是一个数学问题。 对于 n = 1230567，分析数字 1 在千位上出现的次数，可能的形式包括 1221999 ~ 1221000 ，1211999 ~ 1211000 ，… … ，0001999 ~ 0001000 ，共 123 * 1000 次； 对于 n = 1231567，分析数字 1 在千位上出现的次数，可能的形式包括 1231567 ~ 1231000 ， 1221999 ~ 1221000 ，1211999 ~ 1211000 ，… … ，0001999 ~ 0001000 ，共 567 + 1 + 123 * 1000 次； 对于 n = 1232567，分析数字 1 在千位上出现的次数，可能的形式包括 1231999 ~ 1231000 ， 1221999 ~ 1221000 ，1211999 ~ 1211000 ，… … ，0001999 ~ 0001000 ，共 1000 + 123 * 1000 次； 对于 n = 1233567，1234567 ，… … ，结果同上。 故对于 $n=abcdefg$ ，数字 1 在千位上出现的次数为 \left\{ \begin{aligned} &abc*1000, &d=0 \\ &abc*1000+efg+1, &d=1 \\ &abc*1000+1000, &d>1 \\ \end{aligned} \right.同理可得数字 1 在百分位上出现的次数为 \left\{\begin{aligned} &abcd*100, &e=0 \\ &abcd*100+fg+1, &e=1 \\ &abcd*100+100, &e>1 \\\end{aligned}\right.其他数位规律相同，这就是一般规律，可据此编程，注意处理边界情形即可。 1234567891011121314151617181920212223242526class Solution &#123;public: int countDigitOne(int n) &#123; if(n&lt;=0) return 0; // num为数位基数，digit为当前数位，right为当前位右边的数 int num = 10, digit = n%10, right = digit; // n为当前位左边的数 n /= 10; int res; // 个位单独处理 if(digit == 0) res = n; else res = n + 1; while(n)&#123; digit = n%10; n /= 10; if(digit == 0) res += n*num; else if(digit == 1) res += n*num + right + 1; else res += n*num + num; right = digit*num + right; if(n) num *= 10; // 此处n比较大时num可能会在最后一次循环时溢出int的表示范围，故判断一下是否为最后一次循环。 &#125; return res; &#125;&#125;; 此方法时间复杂度为 $O(\log n)$ ，空间复杂度为 $O(1)$ 。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-234-Palindrome Linked List]]></title>
    <url>%2F2020%2F03%2F09%2FLeetCode-234-Palindrome-Linked-List%2F</url>
    <content type="text"><![CDATA[234. Palindrome Linked List Easy Given a singly linked list, determine if it is a palindrome. Example 1: 12Input: 1-&gt;2Output: false Example 2: 12Input: 1-&gt;2-&gt;2-&gt;1Output: true Follow up:Could you do it in O(n) time and O(1) space? Solution先用快慢指针法找到链表的中点，然后将链表的一半反转，最后比较两半链表是否相同。这一过程中涉及很多细节问题，比如节点个数的奇偶性，反转链表的操作等，需要小心处理。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; if(!head || !head-&gt;next) return true; ListNode *mid = head, *p = head; //快慢指针法找中点 while(p &amp;&amp; p-&gt;next)&#123; mid = mid-&gt;next; p = p-&gt;next-&gt;next; &#125; ListNode* temp=mid-&gt;next; p = temp; //反转后一半链表 while(p)&#123; temp = p-&gt;next; p-&gt;next = mid; if(mid-&gt;next == p) mid-&gt;next = NULL; mid = p; p = temp; &#125; p = mid; temp = head; //比较两半链表 while(p &amp;&amp; temp)&#123; if(p-&gt;val != temp-&gt;val) return false; p=p-&gt;next; temp=temp-&gt;next; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-235-Lowest Common Ancestor of a Binary Search Tree]]></title>
    <url>%2F2020%2F03%2F09%2FLeetCode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[235. Lowest Common Ancestor of a Binary Search Tree Easy Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5] Example 1: 123Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8Output: 6Explanation: The LCA of nodes 2 and 8 is 6. Example 2: 123Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4Output: 2Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes’ values will be unique. p and q are different and both values will exist in the BST. Solution递归。若当前节点就是 p , q 之一 ，或者p 和 q 分别位于 当前节点 root 的两边 ，则当前节点即为所求，递归停止。若 p 和 q 都位于 root 的左边，则在左子树中递归地查找 LCA ，否则在右子树中递归查找 LCA 。 12345678910111213141516171819/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; int a = min(p-&gt;val,q-&gt;val), b = max(p-&gt;val,q-&gt;val); if(!root || a == root-&gt;val || b == root-&gt;val || (a &lt; root-&gt;val &amp;&amp; b &gt; root-&gt;val)) return root; if(b &lt; root-&gt;val) return lowestCommonAncestor(root-&gt;left, p, q); else return lowestCommonAncestor(root-&gt;right, p, q); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>BST</tag>
        <tag>二叉排序树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-236-Lowest Common Ancestor of a Binary Tree]]></title>
    <url>%2F2020%2F03%2F09%2FLeetCode-236-Lowest-Common-Ancestor-of-a-Binary-Tree%2F</url>
    <content type="text"><![CDATA[236. Lowest Common Ancestor of a Binary Tree Medium Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4] Example 1: 123Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1Output: 3Explanation: The LCA of nodes 5 and 1 is 3. Example 2: 123Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4Output: 5Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes’ values will be unique. p and q are different and both values will exist in the binary tree. Solution 1用一个 search 函数从根节点开始递归地查找两个节点 p 和 q ，递归过程中用数组 a 和 b 分别记录下查找路径，两条查找路径公共部分地最后一个节点即为所求。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) &#123; vector&lt;TreeNode*&gt; a; vector&lt;TreeNode*&gt; b; search(root, p, a); search(root, q, b); if (a.size() == 0 || b.size() == 0) return 0; int i = a.size() - 1, j = b.size() - 1; while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; a[i] == b[j]) &#123; i--; j--; &#125; return a[i + 1]; &#125; bool search(TreeNode *root, TreeNode *p, vector&lt;TreeNode *&gt; &amp;a) &#123; if (!root) return false; if (root == p || search(root-&gt;left, p, a) || search(root-&gt;right, p, a)) &#123; a.push_back(root); return true; &#125; else return false; &#125;&#125;; 此方法时间复杂度为 $O(n)$，空间复杂度为 $O(树的深度)$。 Solution 2直接用 lowestCommonAncestor 函数进行递归，既可以用它查找节点 p 和 q ，又可以用它查找最近公共祖先，具体看代码注释。 12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q)&#123; // 递归停止条件，当前节点为空或者找到了p,q之一 if(!root || root == p || root == q) return root; TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode *right = lowestCommonAncestor(root-&gt;right, p, q); if(!left &amp;&amp; !right) return NULL; //p,q不在以当前节点为根的子树中，返回空指针。 if(left &amp;&amp; right) return root; //left和right均不为空，说明p,q必然一个在当前节点的左子树中，一个在右子树中，因为递归只要找到任何一个就停止。这种情况下当前节点即为所求。 if(left &amp;&amp; !right) return left; //left不空而right为空说明p,q都在当前节点的左子树中，并且找到了p,q之一，找到的节点就是最终的结果，通过递归逐层返回。 else return right; //与上一种情形相反。 &#125;&#125;; 此方法的复杂度与方法 1 相同。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-237-Delete Node in a Linked List]]></title>
    <url>%2F2020%2F03%2F09%2FLeetCode-237-Delete-Node-in-a-Linked-List%2F</url>
    <content type="text"><![CDATA[237. Delete Node in a Linked List Easy Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list — head = [4,5,1,9], which looks like following: Example 1: 123Input: head = [4,5,1,9], node = 5Output: [4,1,9]Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function. Example 2: 123Input: head = [4,5,1,9], node = 1Output: [4,5,9]Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function. Note: The linked list will have at least two elements. All of the nodes’ values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function. Solution由于只给了指向待删除节点的指针，故将下一个节点的值复制给待删除节点，然后删除下一个节点即可。 123456789101112131415/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void deleteNode(ListNode* node) &#123; node-&gt;val = node-&gt;next-&gt;val; node-&gt;next = node-&gt;next-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Weekly Contest 179]]></title>
    <url>%2F2020%2F03%2F08%2FLeetCode-Weekly-Contest-179%2F</url>
    <content type="text"><![CDATA[LeetCode Weekly Contest 1791374. Generate a String With Characters That Have Odd Counts Easy Given an integer n, _return a string with n characters such that each character in such string occurs an odd number of times_. The returned string must contain only lowercase English letters. If there are multiples valid strings, return any of them. Example 1: 123Input: n = 4Output: &quot;pppz&quot;Explanation: &quot;pppz&quot; is a valid string since the character &apos;p&apos; occurs three times and the character &apos;z&apos; occurs once. Note that there are many other valid strings such as &quot;ohhh&quot; and &quot;love&quot;. Example 2: 123Input: n = 2Output: &quot;xy&quot;Explanation: &quot;xy&quot; is a valid string since the characters &apos;x&apos; and &apos;y&apos; occur once. Note that there are many other valid strings such as &quot;ag&quot; and &quot;ur&quot;. Example 3: 12Input: n = 7Output: &quot;holasss&quot; Constraints: 1 &lt;= n &lt;= 500 Solution若 n 是奇数，返回 n 个 a 组成的串，若 n 是偶数，返回 n-1 个 a 再加一个 b 组成的串 1234567class Solution &#123;public: string generateTheString(int n) &#123; if(n&amp;1) return string(n, 'a'); else return string(n-1, 'a') + 'b'; &#125;&#125;; 1375. Bulb Switcher III Medium There is a room with n bulbs, numbered from 1 to n, arranged in a row from left to right. Initially, all the bulbs are turned off. At moment _k_ (for _k_ from 0 to n - 1), we turn on the light[k] bulb. A bulb change color to blue only if it is on and all the previous bulbs (to the left) are turned on too. Return the number of moments in which all turned on bulbs are blue. Example 1: 123Input: light = [2,1,3,5,4]Output: 3Explanation: All bulbs turned on, are blue at the moment 1, 2 and 4. Example 2: 123Input: light = [3,2,4,1,5]Output: 2Explanation: All bulbs turned on, are blue at the moment 3, and 4 (index-0). Example 3: 1234Input: light = [4,1,2,3]Output: 1Explanation: All bulbs turned on, are blue at the moment 3 (index-0).Bulb 4th changes to blue at the moment 3. Example 4: 12Input: light = [2,1,4,3,6,5]Output: 3 Example 5: 12Input: light = [1,2,3,4,5,6]Output: 6 Constraints: n == light.length 1 &lt;= n &lt;= 5 * 10^4 light is a permutation of [1, 2, ..., n] Solution用 mx 表示当前时刻点燃的灯的最大编号，由于灯的编号为1...n ，如果 mx 恰好等于点燃的灯的数目，则灯 mx 及其之前的灯一定全部点亮了，并且 mx 之后的所有灯一定都未点亮，此时就是一个符合题意的解，计数 res 加一。 1234567891011class Solution &#123;public: int numTimesAllBlue(vector&lt;int&gt;&amp; light) &#123; int mx = 0, res = 0; for(int i=0;i&lt;light.size();i++)&#123; mx = max(mx, light[i]); if(mx == i+1) res++; &#125; return res; &#125;&#125;; 1376. Time Needed to Inform All Employees Medium A company has n employees with a unique ID for each employee from 0 to n - 1. The head of the company has is the one with headID. Each employee has one direct manager given in the manager array where manager[i] is the direct manager of the i-th employee, manager[headID] = -1. Also it’s guaranteed that the subordination relationships have a tree structure. The head of the company wants to inform all the employees of the company of an urgent piece of news. He will inform his direct subordinates and they will inform their subordinates and so on until all employees know about the urgent news. The i-th employee needs informTime[i] minutes to inform all of his direct subordinates (i.e After informTime[i] minutes, all his direct subordinates can start spreading the news). Return _the number of minutes_ needed to inform all the employees about the urgent news. Example 1: 123Input: n = 1, headID = 0, manager = [-1], informTime = [0]Output: 0Explanation: The head of the company is the only employee in the company. Example 2: 1234Input: n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]Output: 1Explanation: The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.The tree structure of the employees in the company is shown. Example 3: 123456789Input: n = 7, headID = 6, manager = [1,2,3,4,5,6,-1], informTime = [0,6,5,4,3,2,1]Output: 21Explanation: The head has id = 6. He will inform employee with id = 5 in 1 minute.The employee with id = 5 will inform the employee with id = 4 in 2 minutes.The employee with id = 4 will inform the employee with id = 3 in 3 minutes.The employee with id = 3 will inform the employee with id = 2 in 4 minutes.The employee with id = 2 will inform the employee with id = 1 in 5 minutes.The employee with id = 1 will inform the employee with id = 0 in 6 minutes.Needed time = 1 + 2 + 3 + 4 + 5 + 6 = 21. Example 4: 12345Input: n = 15, headID = 0, manager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6], informTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]Output: 3Explanation: The first minute the head will inform employees 1 and 2.The second minute they will inform employees 3, 4, 5 and 6.The third minute they will inform the rest of employees. Example 5: 12Input: n = 4, headID = 2, manager = [3,3,-1,2], informTime = [0,0,162,914]Output: 1076 Constraints: 1 &lt;= n &lt;= 10^5 0 &lt;= headID &lt; n manager.length == n 0 &lt;= manager[i] &lt; n manager[headID] == -1 informTime.length == n 0 &lt;= informTime[i] &lt;= 1000 informTime[i] == 0 if employee i has no subordinates. It is guaranteed that all the employees can be informed. Solution 1注意到 manager 数组实际上给出了 children -&gt; parent的逆向关系，所以充分利用这一结构，从叶节点开始向祖先方向逆推到根节点，计算消息从根节点传递到每个叶节点的时间，最终结果就是遍历每个叶节点得到的传递时间的最大值。 123456789101112131415161718class Solution &#123;public: int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) &#123; int res = 0; for(int i=0;i&lt;n;i++)&#123; if(informTime[i] == 0)&#123; int temp_sum = 0; int t = manager[i]; while(t != -1)&#123; temp_sum += informTime[t]; t = manager[t]; &#125; res = max(res, temp_sum); &#125; &#125; return res; &#125;&#125;; 可以看出此方法的时间复杂度为 $O(n\cdot 树的深度)$ ，空间复杂度为 $O(1)$ 。 Solution 2方法 1 中包含一些重复的计算，因为不同叶节点有公共的祖先，而上面的代码对于每一条从根节点到叶节点的路径都完整计算了传递时间，这样对于公共路径部分的计算就重复了。可以用 DP 的方法来消除重复计算，建立一个备忘录数组 dp 来存储已知结果，dp[k] 表示节点 k 收到来自根节点的消息所需要的时间。状态转移方程为 dp[k] = dp[manager[k]] + informTime[manager[k]]. 123456789101112131415161718class Solution &#123;public: int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) &#123; vector&lt;int&gt; dp(n,-1); dp[headID] = 0; int res = 0; for(int i=0;i&lt;n;i++) if(!informTime[i]) res = max(res, rec(dp, i, manager, informTime)); return res; &#125; int rec(vector&lt;int&gt; &amp;dp, int k, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime)&#123; if(dp[k] != -1) return dp[k]; dp[k] = rec(dp, manager[k], manager, informTime) + informTime[manager[k]]; return dp[k]; &#125;&#125;; 此为最优解法，时间复杂度 $O(n)$ ，空间复杂度 $O(n)$ 。 Solution 3DFS 即可，注意要先建立邻接表来存储树。消息从节点 k 传递到 k 的所有子孙节点所用的时间 = informTime[k] + 消息从 k 的所有孩子的传递传递到它的所有子孙节点所用时间的最大值。 123456789101112131415class Solution &#123;public: int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) &#123; vector&lt;vector&lt;int&gt;&gt; children(n); for(int i=0;i&lt;manager.size();i++) if(manager[i] != -1) children[manager[i]].push_back(i); return dfs(children, headID, informTime); &#125; int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; children, int k, vector&lt;int&gt;&amp; informTime)&#123; int time = 0; for(int ch:children[k]) time = max(time, dfs(children, ch, informTime)); return informTime[k] + time; &#125;&#125;; 此方法时间复杂度 $O(n)$ ，但是由于要先建立邻接表，常数因子比方法 2 大；空间复杂度 $O(n)$ 。 1377. Frog Position After T Seconds Hard Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from the vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices it jumps randomly to one of them with the same probability, otherwise, when the frog can not jump to any unvisited vertex it jumps forever on the same vertex. The edges of the undirected tree are given in the array edges, where edges[i] = [fromi, toi] means that exists an edge connecting directly the vertices fromi and toi. _Return the probability that after t seconds the frog is on the vertex target._ Example 1: 123Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4Output: 0.16666666666666666 Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. Example 2: 123Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7Output: 0.3333333333333333Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1. Example 3: 12Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 20, target = 6Output: 0.16666666666666666 Constraints: 1 &lt;= n &lt;= 100 edges.length == n-1 edges[i].length == 2 1 &lt;= edges[i][0], edges[i][1] &lt;= n 1 &lt;= t &lt;= 50 1 &lt;= target &lt;= n Answers within 10^-5 of the actual value will be accepted as correct. Solution（待补充…）]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>LeetCode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-238-Product of Array Except Self]]></title>
    <url>%2F2020%2F03%2F07%2FLeetCode-238-Product-of-Array-Except-Self%2F</url>
    <content type="text"><![CDATA[238. Product of Array Except Self Medium Given an array nums of _n_ integers where _n_ > 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Example: 12Input: [1,2,3,4]Output: [24,12,8,6] Constraint: It’s guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer. Note: Please solve it without division and in O(_n_). Follow up:Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.) Solution建立两个数组 left[i] 和 right[i]，left[i]记录数组从 0 到 i 段的乘积，right[i] 记录数组从 i 到 len -1 段的乘积，结果 res[i] = left[i-1] * right[i+1] 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); vector&lt;int&gt; left(len); left[0] = nums[0]; vector&lt;int&gt; right(len); right[len-1] = nums[len-1]; for(int i=1;i&lt;len;i++) left[i] = left[i-1]*nums[i]; for(int i=len-2;i&gt;=0;i--) right[i] = right[i+1]*nums[i]; vector&lt;int&gt; res; res.push_back(right[1]); for(int i=1;i&lt;len-1;i++) res.push_back(left[i-1]*right[i+1]); res.push_back(left[len-2]); return res; &#125;&#125;; 并把循环合并一下，用两个整数 left 和 right 代替数组，可得到空间复杂度为 $O(1)$ 的代码： 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); vector&lt;int&gt; res(len,1); int left = nums[0], right = nums[len-1]; for(int i=1;i&lt;len-1;i++)&#123; res[i] *= left; left *= nums[i]; res[len-i-1] *= right; right *= nums[len-i-1]; &#125; res[0] = right; res[len-1] = left; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-239-Sliding Window Maximum]]></title>
    <url>%2F2020%2F03%2F07%2FLeetCode-239-Sliding-Window-Maximum%2F</url>
    <content type="text"><![CDATA[239. Sliding Window Maximum Hard Given an array _nums_, there is a sliding window of size _k_ which is moving from the very left of the array to the very right. You can only see the _k_ numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: 123456789101112Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7] Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Note:You may assume _k_ is always valid, 1 ≤ k ≤ input array’s size for non-empty array. Follow up:Could you solve it in linear time? Solution单调队列的典型题。单调队列是指维护一个具有单调性的队列，只能从队尾入队，但从队头和队尾两端都可以出队，一般用标准库的双端队列实现。 本题求一个范围内的最大值，因此维护一个单调递减队列，队头就是最大元。该队列的维护逻辑如下： 若队列为空，当前元素直接入队； 若队尾元素大于或等于当前元素，当前元素直接入队，这样保持了队列的单调递减特性。从题意上讲，当前元素虽然比队列中的元素都小，但是它出现的晚，随着窗口的滑动队列中比它大的元素可能不在窗口内了，当前元素有成为某个滑动窗口最大值的潜力； 若队尾元素小于当前元素，则弹出队尾元素，重复此过程直到遇到比当前元素大的或者队列变空为止，然后当前元素入队。从题意上讲，当前元素不仅比队列中的某些元素大，还出现的更晚，因此队列中那些比它小的元素没有成为某个滑动窗口最大值的的可能了，因此丢掉； 每滑动一步，检查队头元素是否还在窗口内，如果不在了就弹出队头元素。 由于要检查队头元素是否在窗口内，因此本题的单调队列保存值的索引而不是值本身，这样更方便操作。 1234567891011121314class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; deque&lt;int&gt; dq; vector&lt;int&gt; res; for(int i=0;i&lt;nums.size();i++)&#123; while(dq.size() != 0 &amp;&amp; nums[dq.back()] &lt; nums[i]) dq.pop_back(); dq.push_back(i); if(dq.front() &lt; i-k+1) dq.pop_front(); if(i &gt;= k-1) res.push_back(nums[dq.front()]); &#125; return res; &#125;&#125;; 时间复杂度为 $O(n)$。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeeoCode-240-Search a 2D Matrix II]]></title>
    <url>%2F2020%2F03%2F07%2FLeetCode-240-Search-a-2D-Matrix-II%2F</url>
    <content type="text"><![CDATA[240. Search a 2D Matrix II Medium Write an efficient algorithm that searches for a value in an _m_ x _n_ matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example: Consider the following matrix: 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] Given target = 5, return true. Given target = 20, return false. Solution注意到任何一个元素左上方的元素都比它小，右下方的元素都比它大，因此可以从最右上的元素开始搜索，遇到比待查找元素小的就向下搜索，遇到比待查找元素大的就向左搜索，直到找到该元素或者碰到边界为止。当然，从最左下的元素开始搜索也一样。 12345678910111213141516class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if(matrix.size() == 0) return false; int m = matrix.size(); int n = matrix[0].size(); int i = 0, j = n-1; while(i&lt;m &amp;&amp; j&gt;=0)&#123; if(matrix[i][j] == target) return true; else if(matrix[i][j] &gt; target) j--; else i++; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>矩阵</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-241-Different Ways to Add Parentheses]]></title>
    <url>%2F2020%2F03%2F06%2FLeetCode-241-Different-Ways-to-Add-Parentheses%2F</url>
    <content type="text"><![CDATA[241. Different Ways to Add Parentheses Medium Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 1: 12345Input: &quot;2-1-1&quot;Output: [0, 2]Explanation: ((2-1)-1) = 0 (2-(1-1)) = 2 Example 2: 12345678Input: &quot;2*3-4*5&quot;Output: [-34, -14, -10, -10, 10]Explanation: (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10 Solution 1分治法。对于每个运算符分成左右两段，递归计算做左边的所有可能取值和右边的所有可能取值，再把左右两边通过当前运算符计算的所有值存到结果集中。 123456789101112131415161718192021222324252627vector&lt;int&gt; diffWaysToCompute(string input)&#123; vector&lt;int&gt; res; for (int i = 0; i &lt; input.length(); i++) &#123; if (input[i] == '+' || input[i] == '-' || input[i] == '*') &#123; vector&lt;int&gt; res_left = diffWaysToCompute(input.substr(0, i)); vector&lt;int&gt; res_right = diffWaysToCompute(input.substr(i + 1)); for (int a : res_left) &#123; for (int b : res_right) &#123; if (input[i] == '+') res.push_back(a + b); else if (input[i] == '-') res.push_back(a - b); else res.push_back(a * b); &#125; &#125; &#125; &#125; if (res.empty()) //当前串只含数字 res.push_back(atoi(input.c_str())); return res;&#125; Solution 2DP。注意到在上面的递归中有很多重复计算，所以可以建立一个备忘录，用查表的方式避免重复计算。自顶向下递归式DP的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738vector&lt;int&gt; diffWaysToCompute(string input)&#123; unordered_map&lt;string, vector&lt;int&gt;&gt; dp; return cal(input, dp);&#125;vector&lt;int&gt; cal(string input, unordered_map&lt;string, vector&lt;int&gt;&gt; &amp;dp)&#123; if (dp.find(input) != dp.end()) return dp[input]; vector&lt;int&gt; res; for (int i = 0; i &lt; input.length(); i++) &#123; if (input[i] == '+' || input[i] == '-' || input[i] == '*') &#123; string s_left = input.substr(0, i); string s_right = input.substr(i + 1); vector&lt;int&gt; res_left = cal(s_left, dp); vector&lt;int&gt; res_right = cal(s_right, dp); for (int a : res_left) &#123; for (int b : res_right) &#123; if (input[i] == '+') res.push_back(a + b); else if (input[i] == '-') res.push_back(a - b); else res.push_back(a * b); &#125; &#125; &#125; &#125; if (res.empty()) res.push_back(atoi(input.c_str())); dp[input] = res; return res;&#125; Follow up 不用递归，自底向上的迭代式 DP 如何写？ 本题的复杂度如何分析？]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-242-Valid Anagram]]></title>
    <url>%2F2020%2F03%2F05%2FLeetCode-242-Valid-Anagram%2F</url>
    <content type="text"><![CDATA[242. Valid Anagram Easy Given two strings _s_ and _t_, write a function to determine if _t_ is an anagram of _s_. Example 1: 12Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;Output: true Example 2: 12Input: s = &quot;rat&quot;, t = &quot;car&quot;Output: false Note:You may assume the string contains only lowercase alphabets. Follow up:What if the inputs contain unicode characters? How would you adapt your solution to such case? Solution建立一个 Hash 表来计数，如果字符串中只包含小写字母，可以直接用数组来计数。 1234567891011121314class Solution &#123;public: bool isAnagram(string s, string t) &#123; if(s.length() != t.length()) return false; unordered_map&lt;char,int&gt; count; for(int i=0;i&lt;s.length();i++)&#123; count[s[i]]++; count[t[i]]--; &#125; for(auto x:count) if(x.second) return false; return true; &#125;&#125;; 注意这里利用了 map 的初始化特性，对于语句 count[s[i]];, 如果 count 中没有键 s[i]，将自动插入改该键并将相应的值初始化为 0。因此 count[s[i]]++; 无需检测 s[i] 的存在性。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>易位串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-257-Binary Tree Paths]]></title>
    <url>%2F2020%2F03%2F05%2FLeetCode-257-Binary-Tree-Paths%2F</url>
    <content type="text"><![CDATA[257. Binary Tree PathsEasy Given a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: 1234567891011Input: 1 / \2 3 \ 5Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3 Solution递归。需要3个参数：当前节点，当前节点的祖先节点组成的路径（用字符串保存），当前结果集（字符串数组）。 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; res; string ans = ""; visit(root, ans, res); return res; &#125; void visit(TreeNode* p, string ans, vector&lt;string&gt; &amp;res)&#123; if(!p) return; if(!p-&gt;left &amp;&amp; !p-&gt;right)&#123; ans += to_string(p-&gt;val); res.push_back(ans); return; &#125; ans += to_string(p-&gt;val) + "-&gt;"; if(p-&gt;left) visit(p-&gt;left, ans, res); if(p-&gt;right) visit(p-&gt;right, ans, res); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-01-两数之和-Two Sum]]></title>
    <url>%2F2019%2F11%2F22%2FLeetCode-01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-Two-Sum%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-07-整数逆序-Reverse-Integer]]></title>
    <url>%2F2019%2F10%2F16%2FLeetCode-07-%E6%95%B4%E6%95%B0%E9%80%86%E5%BA%8F-Reverse-Integer%2F</url>
    <content type="text"><![CDATA[本题算法层面无需赘述，唯一值得注意的是int溢出的检查，这可能涉及一些具体语言特性相关的知识。对C++而言，以下几个知识点可能有所帮助： 预定义常量：int最大正数INT_MAX，最小负数INT_MIN，其他类型也有类似常量定义 整数类型：一般而言 short，int，long long 分别为2字节，4字节，8字节整数，值得注意的是 long 一般与 int 相同，这一特殊情形是历史原因造成的。int，long 等类型的实际宽度与机器字长、编译器等因素均有关 代码中数字常量的默认类型：对于正数，按照 int $\rightarrow$ unsigned int $\rightarrow$ long long $\rightarrow$ unsigned long long 匹配；对于浮点数和科学计数法，一律为double型。超出最大表示范围的数字常量会报错 本题代码如下： 1234567891011121314class Solution &#123;public: int reverse(int x) &#123; long long result = 0; while (x != 0) &#123; result = result * static_cast&lt;long long&gt;(10) + static_cast&lt;long long&gt;(x % 10); x /= 10; &#125; if (result &gt; INT_MAX || result &lt; INT_MIN) return 0; else return static_cast&lt;int&gt;(result); &#125;&#125;; 循环次数为十进制整数的位数，因此复杂度为$O(\mathrm{log}_{10} n)$ 。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>整数逆序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-06-之字形转换-ZigZag-Conversion]]></title>
    <url>%2F2019%2F10%2F15%2FLeetCode-06-%E4%B9%8B%E5%AD%97%E5%BD%A2%E8%BD%AC%E6%8D%A2-ZigZag-Conversion%2F</url>
    <content type="text"><![CDATA[写几个例子找规律即可，不难发现转换后第一行和最后一行的字符在原串中的索引构成等差数列，中间行的字符在原串中的索引构成“双“等差数列（$a_1=a_0+d_1, a_2=a_1+d_2, a_3=a_2+d_1, \cdots$），找出三个公差即可。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: string convert(string s, int numRows) &#123; int L = s.length(); //行数为1或者行数不小于s的长度返回s即可 if (numRows == 1 || numRows &gt;= L) return s; string szz = ""; //保存结果 for (int i = 1; i &lt;= numRows; i++) &#123; //处理第一行和最后一行，等差数列 if(i == 1 || i == numRows) &#123; int j = i - 1; while(j &lt; L) &#123; szz += s[j]; j += 2 * (numRows - 1); &#125; &#125; //中间的行，“双”等差数列 else &#123; int j = i - 1; while (j &lt; L) &#123; szz += s[j]; j += 2 * (numRows - i); if (j &lt; L) &#123; szz += s[j]; j += 2 * (i - 1); &#125; &#125; &#125; &#125; return szz; &#125;&#125;; 每次操作均能确定目标串的一个字符，时间复杂度为$O(n)$。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>之字形转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-05.最长回文子串(LPS)]]></title>
    <url>%2F2019%2F10%2F09%2FLeetCode-05-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-LPS%2F</url>
    <content type="text"><![CDATA[先找出每个对称中心对应的LPS的长度，然后取最长的即可。注意奇数长度的串和偶数长度的串情况是不一样的，对称中心可以是元素本身也可以是元素间的间隙。若将所有间隙全部填充上同一字符（不能是串中出现的字符），便可统一为奇数情形进行处理，如 “ada” 变为 “a#d#a” ， “adaa” 变为 “a#d#a#a” 。 代码如下，这里不进行填充而是分情况讨论: 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string longestPalindrome(string s) &#123; int L = s.length(); int k = 0, len = 0; for (int i = 0; i &lt; L; i++) &#123; //考虑s[i]为对称中心 int pr1 = 1; //回文半径(包含中心) while (i - pr1 &gt;= 0 &amp;&amp; i + pr1 &lt; L &amp;&amp; s[i - pr1] == s[i + pr1]) pr1++; //考虑s[i]与s[i+1]之间的空隙为对称中心 int pr2 = 0; //回文半径 while (i - pr2 &gt;= 0 &amp;&amp; i + pr2 + 1 &lt; L &amp;&amp; s[i - pr2] == s[i + pr2 + 1]) pr2++; int len1 = 2 * (pr1 - 1) + 1; int len2 = 2 * pr2; if (max(len1, len2) &gt; len) &#123; if (len1 &gt; len2) &#123; k = i - pr1 + 1; len = len1; &#125; else &#123; k = i - pr2 + 1; len = len2; &#125; &#125; &#125; return s.substr(k, len); &#125;&#125;; 该算法时间复杂度显然为$O(n^2)$，提交LeetCode发现AC了。 实际上，有一种Manacher算法能够在$O(n)$时间内找到LPS，不过这是一种非通用算法，即该算法只能应用于解决LPS问题，因而实用价值不高。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>LPS</tag>
      </tags>
  </entry>
</search>
