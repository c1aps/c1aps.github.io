<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode-225-Implement Stack using Queues-用队列实现栈]]></title>
    <url>%2F2020%2F03%2F16%2FLeetCode-225-Implement-Stack-using-Queues-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%2F</url>
    <content type="text"><![CDATA[225. Implement Stack using Queues Easy Description Solution用一个队列的队头表示栈顶，队尾表示栈底。第 k 个元素入栈的时候先将其从队尾入队，然后将前面的 k-1 个元素依次从队头出队并从队尾入队。由于队列是 FIFO 的数据结构，这样能够保持先入栈的元素始终更靠近队头，也即更靠近栈顶，恰好符合栈的定义。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class MyStack &#123; queue&lt;int&gt; q;public: /** Initialize your data structure here. */ MyStack() &#123; &#125; /** Push element x onto stack. */ void push(int x) &#123; q.push(x); int k = q.size() - 1; while(k--)&#123; q.push(q.front()); q.pop(); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ int pop() &#123; int res = top(); q.pop(); return res; &#125; /** Get the top element. */ int top() &#123; return q.front(); &#125; /** Returns whether the stack is empty. */ bool empty() &#123; return q.empty(); &#125;&#125;;/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */ 此方法时间复杂度为 push $O(n)$ ，pop/top/empty $O(1)$ 。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-225-Implement Stack using Queues]]></title>
    <url>%2F2020%2F03%2F16%2FLeetCode-225-Implement-Stack-using-Queues%2F</url>
    <content type="text"><![CDATA[225. Implement Stack using Queues Easy DescriptionGo to LeetCode Solution用一个队列的队头表示栈顶，队尾表示栈底。第 k 个元素入栈的时候先将其从队尾入队，然后将前面的 k-1 个元素依次从队头出队并从队尾入队。由于队列是 FIFO 的数据结构，这样能够保持先入栈的元素始终更靠近队头，也即更靠近栈顶，恰好符合栈的定义。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class MyStack &#123; queue&lt;int&gt; q;public: /** Initialize your data structure here. */ MyStack() &#123; &#125; /** Push element x onto stack. */ void push(int x) &#123; q.push(x); int k = q.size() - 1; while(k--)&#123; q.push(q.front()); q.pop(); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ int pop() &#123; int res = top(); q.pop(); return res; &#125; /** Get the top element. */ int top() &#123; return q.front(); &#125; /** Returns whether the stack is empty. */ bool empty() &#123; return q.empty(); &#125;&#125;;/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */ 此方法时间复杂度为 push $O(n)$ ，pop/top/empty $O(1)$ 。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-224-Basic Calculator]]></title>
    <url>%2F2020%2F03%2F15%2FLeetCode-224-Basic-Calculator%2F</url>
    <content type="text"><![CDATA[224. Basic Calculator Hard Implement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces . Example 1: 12Input: &quot;1 + 1&quot;Output: 2 Example 2: 12Input: &quot; 2-1 + 2 &quot;Output: 3 Example 3: 12Input: &quot;(1+(4+5+2)-3)+(6+8)&quot;Output: 23 Note: You may assume that the given expression is always valid. Do not use the eval built-in library function. Solution由于表达式只含加减法，故只需要确定每个数在最终结果中的符号，最后相加即可。对于括号外的数，其最终符号就是数字前面的符号；对于括号里面的数，其最终的符号与数字前面的符号以及所有包含它的括号的符号均相关。 用 1 和 -1 分别表示正负号，考虑最外层括号，设 s 为最外层括号的符号，那么对于这层括号里面的任何一项（包含数字或者括号），设其本来的符号为 t ，则这一项在这层括号去掉后的符号为 s*t 。根据这一规律，便可以逐层求得括号里面的数的最终符号，相当于逐层去括号。 编程实现的核心要点是用一个栈 stk 保存每一层括号成为最外层括号时的符号 。 1234567891011121314151617181920212223class Solution &#123;public: int calculate(string s) &#123; int res = 0, num = 0, sign = 1; stack&lt;int&gt; stk; stk.push(sign); for(auto x:s)&#123; if(x &gt;= '0' &amp;&amp; x &lt;= '9') num = num*10 + (x-'0'); //这个括号必须加，不然先计算前面的加法可能溢出 else if(x == '+' || x == '-')&#123; res += sign*num; sign = stk.top()*(x=='+' ? 1 : -1); num = 0; &#125; else if(x == '(') stk.push(sign); else if(x == ')') stk.pop(); &#125; res += sign*num; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-230-Kth Smallest Element in a BST]]></title>
    <url>%2F2020%2F03%2F11%2FLeetCode-230-Kth-Smallest-Element-in-a-BST%2F</url>
    <content type="text"><![CDATA[230. Kth Smallest Element in a BST Medium Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:You may assume k is always valid, 1 ≤ k ≤ BST’s total elements. Example 1: 1234567Input: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2Output: 1 Example 2: 123456789Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1Output: 3 Follow up:What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine? SolutionBST 的特点是其中序遍历就是递增序列，故利用二叉树非递归形式的中序遍历结合简单计数便可找到所求元素。 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int kthSmallest(TreeNode* root, int k) &#123; TreeNode *p = root; stack&lt;TreeNode*&gt; stk; while(p || !stk.empty())&#123; while(p)&#123; stk.push(p); p = p-&gt;left; &#125; if(!stk.empty())&#123; p = stk.top(); if(!(--k)) return p-&gt;val; stk.pop(); p = p-&gt;right; &#125; &#125; return 0; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-231-Power of Two]]></title>
    <url>%2F2020%2F03%2F11%2FLeetCode-231-Power-of-Two%2F</url>
    <content type="text"><![CDATA[231. Power of Two Easy Given an integer, write a function to determine if it is a power of two. Example 1: 123Input: 1Output: true Explanation: 20 = 1 Example 2: 123Input: 16Output: trueExplanation: 24 = 16 Example 3: 12Input: 218Output: false Solution注意到 2 的幂的特点是其二进制表示中只有一个 1 ，其余数位全部为 0 ，可以用 n &amp; n-1 的技巧来检验这一点： 若 n 是 2 的幂，设其二进制中第 k 位为 1 ，则 n-1 的二进制必然是1 ~ k - 1位均为 1 ，其余位为0 。这样 n &amp; n-1 必为 0 ； 若 n &gt; 0 不是 2 的幂，则其二进制中必然包含至少两个 1 ，设位次最小的两个 1 分别在 k, m 位 (k &lt; m) ，则n-1 的二进制必然是1 ~ k - 1位均为 1，第 k 位为 0 ，第 m 位以及更高位的 1 均保持不变。这样 n &amp; n-1 必不为 0 。 123456class Solution &#123;public: bool isPowerOfTwo(int n) &#123; return n&gt;0 &amp;&amp; !(n&amp;(n-1)); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-232-Implement Queue using Stacks]]></title>
    <url>%2F2020%2F03%2F11%2FLeetCode-232-Implement-Queue-using-Stacks%2F</url>
    <content type="text"><![CDATA[232. Implement Queue using Stacks Easy Implement the following operations of a queue using stacks. push(x) — Push element x to the back of queue. pop() — Removes the element from in front of queue. peek() — Get the front element. empty() — Return whether the queue is empty. Example: 1234567MyQueue queue = new MyQueue();queue.push(1);queue.push(2); queue.peek(); // returns 1queue.pop(); // returns 1queue.empty(); // returns false Notes: You must use _only_ standard operations of a stack — which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). Solution想象两个栈的栈底连在一起，一个作为队尾，一个作为队头。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class MyQueue &#123; stack&lt;int&gt; stk_head; stack&lt;int&gt; stk_tail;public: /** Initialize your data structure here. */ MyQueue() &#123; &#125; /** Push element x to the back of queue. */ void push(int x) &#123; stk_tail.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; if(!empty())&#123; int res = peek(); stk_head.pop(); return res; &#125; else return 0; &#125; /** Get the front element. */ int peek() &#123; if(!stk_head.empty()) return stk_head.top(); else if(!stk_tail.empty())&#123; while(!stk_tail.empty())&#123; int temp = stk_tail.top(); stk_tail.pop(); stk_head.push(temp); &#125; return stk_head.top(); &#125; else return 0; &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return stk_head.empty() &amp;&amp; stk_tail.empty(); &#125;&#125;;/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-233-Number of Digit One]]></title>
    <url>%2F2020%2F03%2F10%2FLeetCode-233-Number-of-Digit-One%2F</url>
    <content type="text"><![CDATA[233. Number of Digit One Hard Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. Example: 123Input: 13Output: 6 Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13. SolutionBroute - Force 将会超时。 显然本题应当从数字 1 在 n 的任一数位上出现的次数分析，找出规律，本质上是一个数学问题。 对于 n = 1230567，分析数字 1 在千位上出现的次数，可能的形式包括 1221999 ~ 1221000 ，1211999 ~ 1211000 ，… … ，0001999 ~ 0001000 ，共 123 * 1000 次； 对于 n = 1231567，分析数字 1 在千位上出现的次数，可能的形式包括 1231567 ~ 1231000 ， 1221999 ~ 1221000 ，1211999 ~ 1211000 ，… … ，0001999 ~ 0001000 ，共 567 + 1 + 123 * 1000 次； 对于 n = 1232567，分析数字 1 在千位上出现的次数，可能的形式包括 1231999 ~ 1231000 ， 1221999 ~ 1221000 ，1211999 ~ 1211000 ，… … ，0001999 ~ 0001000 ，共 1000 + 123 * 1000 次； 对于 n = 1233567，1234567 ，… … ，结果同上。 故对于 $n=abcdefg$ ，数字 1 在千位上出现的次数为 \left\{ \begin{aligned} &abc*1000, &d=0 \\ &abc*1000+efg+1, &d=1 \\ &abc*1000+1000, &d>1 \\ \end{aligned} \right.同理可得数字 1 在百分位上出现的次数为 \left\{\begin{aligned} &abcd*100, &e=0 \\ &abcd*100+fg+1, &e=1 \\ &abcd*100+100, &e>1 \\\end{aligned}\right.其他数位规律相同，这就是一般规律，可据此编程，注意处理边界情形即可。 1234567891011121314151617181920212223242526class Solution &#123;public: int countDigitOne(int n) &#123; if(n&lt;=0) return 0; // num为数位基数，digit为当前数位，right为当前位右边的数 int num = 10, digit = n%10, right = digit; // n为当前位左边的数 n /= 10; int res; // 个位单独处理 if(digit == 0) res = n; else res = n + 1; while(n)&#123; digit = n%10; n /= 10; if(digit == 0) res += n*num; else if(digit == 1) res += n*num + right + 1; else res += n*num + num; right = digit*num + right; if(n) num *= 10; // 此处n比较大时num可能会在最后一次循环时溢出int的表示范围，故判断一下是否为最后一次循环。 &#125; return res; &#125;&#125;; 此方法时间复杂度为 $O(\log n)$ ，空间复杂度为 $O(1)$ 。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-234-Palindrome Linked List]]></title>
    <url>%2F2020%2F03%2F09%2FLeetCode-234-Palindrome-Linked-List%2F</url>
    <content type="text"><![CDATA[234. Palindrome Linked List Easy Given a singly linked list, determine if it is a palindrome. Example 1: 12Input: 1-&gt;2Output: false Example 2: 12Input: 1-&gt;2-&gt;2-&gt;1Output: true Follow up:Could you do it in O(n) time and O(1) space? Solution先用快慢指针法找到链表的中点，然后将链表的一半反转，最后比较两半链表是否相同。这一过程中涉及很多细节问题，比如节点个数的奇偶性，反转链表的操作等，需要小心处理。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; if(!head || !head-&gt;next) return true; ListNode *mid = head, *p = head; //快慢指针法找中点 while(p &amp;&amp; p-&gt;next)&#123; mid = mid-&gt;next; p = p-&gt;next-&gt;next; &#125; ListNode* temp=mid-&gt;next; p = temp; //反转后一半链表 while(p)&#123; temp = p-&gt;next; p-&gt;next = mid; if(mid-&gt;next == p) mid-&gt;next = NULL; mid = p; p = temp; &#125; p = mid; temp = head; //比较两半链表 while(p &amp;&amp; temp)&#123; if(p-&gt;val != temp-&gt;val) return false; p=p-&gt;next; temp=temp-&gt;next; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-235-Lowest Common Ancestor of a Binary Search Tree]]></title>
    <url>%2F2020%2F03%2F09%2FLeetCode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[235. Lowest Common Ancestor of a Binary Search Tree Easy Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5] Example 1: 123Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8Output: 6Explanation: The LCA of nodes 2 and 8 is 6. Example 2: 123Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4Output: 2Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes’ values will be unique. p and q are different and both values will exist in the BST. Solution递归。若当前节点就是 p , q 之一 ，或者p 和 q 分别位于 当前节点 root 的两边 ，则当前节点即为所求，递归停止。若 p 和 q 都位于 root 的左边，则在左子树中递归地查找 LCA ，否则在右子树中递归查找 LCA 。 12345678910111213141516171819/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; int a = min(p-&gt;val,q-&gt;val), b = max(p-&gt;val,q-&gt;val); if(!root || a == root-&gt;val || b == root-&gt;val || (a &lt; root-&gt;val &amp;&amp; b &gt; root-&gt;val)) return root; if(b &lt; root-&gt;val) return lowestCommonAncestor(root-&gt;left, p, q); else return lowestCommonAncestor(root-&gt;right, p, q); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>BST</tag>
        <tag>二叉排序树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-236-Lowest Common Ancestor of a Binary Tree]]></title>
    <url>%2F2020%2F03%2F09%2FLeetCode-236-Lowest-Common-Ancestor-of-a-Binary-Tree%2F</url>
    <content type="text"><![CDATA[236. Lowest Common Ancestor of a Binary Tree Medium Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4] Example 1: 123Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1Output: 3Explanation: The LCA of nodes 5 and 1 is 3. Example 2: 123Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4Output: 5Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes’ values will be unique. p and q are different and both values will exist in the binary tree. Solution 1用一个 search 函数从根节点开始递归地查找两个节点 p 和 q ，递归过程中用数组 a 和 b 分别记录下查找路径，两条查找路径公共部分地最后一个节点即为所求。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) &#123; vector&lt;TreeNode*&gt; a; vector&lt;TreeNode*&gt; b; search(root, p, a); search(root, q, b); if (a.size() == 0 || b.size() == 0) return 0; int i = a.size() - 1, j = b.size() - 1; while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; a[i] == b[j]) &#123; i--; j--; &#125; return a[i + 1]; &#125; bool search(TreeNode *root, TreeNode *p, vector&lt;TreeNode *&gt; &amp;a) &#123; if (!root) return false; if (root == p || search(root-&gt;left, p, a) || search(root-&gt;right, p, a)) &#123; a.push_back(root); return true; &#125; else return false; &#125;&#125;; 此方法时间复杂度为 $O(n)$，空间复杂度为 $O(树的深度)$。 Solution 2直接用 lowestCommonAncestor 函数进行递归，既可以用它查找节点 p 和 q ，又可以用它查找最近公共祖先，具体看代码注释。 12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q)&#123; // 递归停止条件，当前节点为空或者找到了p,q之一 if(!root || root == p || root == q) return root; TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode *right = lowestCommonAncestor(root-&gt;right, p, q); if(!left &amp;&amp; !right) return NULL; //p,q不在以当前节点为根的子树中，返回空指针。 if(left &amp;&amp; right) return root; //left和right均不为空，说明p,q必然一个在当前节点的左子树中，一个在右子树中，因为递归只要找到任何一个就停止。这种情况下当前节点即为所求。 if(left &amp;&amp; !right) return left; //left不空而right为空说明p,q都在当前节点的左子树中，并且找到了p,q之一，找到的节点就是最终的结果，通过递归逐层返回。 else return right; //与上一种情形相反。 &#125;&#125;; 此方法的复杂度与方法 1 相同。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-237-Delete Node in a Linked List]]></title>
    <url>%2F2020%2F03%2F09%2FLeetCode-237-Delete-Node-in-a-Linked-List%2F</url>
    <content type="text"><![CDATA[237. Delete Node in a Linked List Easy Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list — head = [4,5,1,9], which looks like following: Example 1: 123Input: head = [4,5,1,9], node = 5Output: [4,1,9]Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function. Example 2: 123Input: head = [4,5,1,9], node = 1Output: [4,5,9]Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function. Note: The linked list will have at least two elements. All of the nodes’ values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function. Solution由于只给了指向待删除节点的指针，故将下一个节点的值复制给待删除节点，然后删除下一个节点即可。 123456789101112131415/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void deleteNode(ListNode* node) &#123; node-&gt;val = node-&gt;next-&gt;val; node-&gt;next = node-&gt;next-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Weekly Contest 179]]></title>
    <url>%2F2020%2F03%2F08%2FLeetCode-Weekly-Contest-179%2F</url>
    <content type="text"><![CDATA[LeetCode Weekly Contest 1791374. Generate a String With Characters That Have Odd Counts Easy Given an integer n, _return a string with n characters such that each character in such string occurs an odd number of times_. The returned string must contain only lowercase English letters. If there are multiples valid strings, return any of them. Example 1: 123Input: n = 4Output: &quot;pppz&quot;Explanation: &quot;pppz&quot; is a valid string since the character &apos;p&apos; occurs three times and the character &apos;z&apos; occurs once. Note that there are many other valid strings such as &quot;ohhh&quot; and &quot;love&quot;. Example 2: 123Input: n = 2Output: &quot;xy&quot;Explanation: &quot;xy&quot; is a valid string since the characters &apos;x&apos; and &apos;y&apos; occur once. Note that there are many other valid strings such as &quot;ag&quot; and &quot;ur&quot;. Example 3: 12Input: n = 7Output: &quot;holasss&quot; Constraints: 1 &lt;= n &lt;= 500 Solution若 n 是奇数，返回 n 个 a 组成的串，若 n 是偶数，返回 n-1 个 a 再加一个 b 组成的串 1234567class Solution &#123;public: string generateTheString(int n) &#123; if(n&amp;1) return string(n, 'a'); else return string(n-1, 'a') + 'b'; &#125;&#125;; 1375. Bulb Switcher III Medium There is a room with n bulbs, numbered from 1 to n, arranged in a row from left to right. Initially, all the bulbs are turned off. At moment _k_ (for _k_ from 0 to n - 1), we turn on the light[k] bulb. A bulb change color to blue only if it is on and all the previous bulbs (to the left) are turned on too. Return the number of moments in which all turned on bulbs are blue. Example 1: 123Input: light = [2,1,3,5,4]Output: 3Explanation: All bulbs turned on, are blue at the moment 1, 2 and 4. Example 2: 123Input: light = [3,2,4,1,5]Output: 2Explanation: All bulbs turned on, are blue at the moment 3, and 4 (index-0). Example 3: 1234Input: light = [4,1,2,3]Output: 1Explanation: All bulbs turned on, are blue at the moment 3 (index-0).Bulb 4th changes to blue at the moment 3. Example 4: 12Input: light = [2,1,4,3,6,5]Output: 3 Example 5: 12Input: light = [1,2,3,4,5,6]Output: 6 Constraints: n == light.length 1 &lt;= n &lt;= 5 * 10^4 light is a permutation of [1, 2, ..., n] Solution用 mx 表示当前时刻点燃的灯的最大编号，由于灯的编号为1...n ，如果 mx 恰好等于点燃的灯的数目，则灯 mx 及其之前的灯一定全部点亮了，并且 mx 之后的所有灯一定都未点亮，此时就是一个符合题意的解，计数 res 加一。 1234567891011class Solution &#123;public: int numTimesAllBlue(vector&lt;int&gt;&amp; light) &#123; int mx = 0, res = 0; for(int i=0;i&lt;light.size();i++)&#123; mx = max(mx, light[i]); if(mx == i+1) res++; &#125; return res; &#125;&#125;; 1376. Time Needed to Inform All Employees Medium A company has n employees with a unique ID for each employee from 0 to n - 1. The head of the company has is the one with headID. Each employee has one direct manager given in the manager array where manager[i] is the direct manager of the i-th employee, manager[headID] = -1. Also it’s guaranteed that the subordination relationships have a tree structure. The head of the company wants to inform all the employees of the company of an urgent piece of news. He will inform his direct subordinates and they will inform their subordinates and so on until all employees know about the urgent news. The i-th employee needs informTime[i] minutes to inform all of his direct subordinates (i.e After informTime[i] minutes, all his direct subordinates can start spreading the news). Return _the number of minutes_ needed to inform all the employees about the urgent news. Example 1: 123Input: n = 1, headID = 0, manager = [-1], informTime = [0]Output: 0Explanation: The head of the company is the only employee in the company. Example 2: 1234Input: n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]Output: 1Explanation: The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.The tree structure of the employees in the company is shown. Example 3: 123456789Input: n = 7, headID = 6, manager = [1,2,3,4,5,6,-1], informTime = [0,6,5,4,3,2,1]Output: 21Explanation: The head has id = 6. He will inform employee with id = 5 in 1 minute.The employee with id = 5 will inform the employee with id = 4 in 2 minutes.The employee with id = 4 will inform the employee with id = 3 in 3 minutes.The employee with id = 3 will inform the employee with id = 2 in 4 minutes.The employee with id = 2 will inform the employee with id = 1 in 5 minutes.The employee with id = 1 will inform the employee with id = 0 in 6 minutes.Needed time = 1 + 2 + 3 + 4 + 5 + 6 = 21. Example 4: 12345Input: n = 15, headID = 0, manager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6], informTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]Output: 3Explanation: The first minute the head will inform employees 1 and 2.The second minute they will inform employees 3, 4, 5 and 6.The third minute they will inform the rest of employees. Example 5: 12Input: n = 4, headID = 2, manager = [3,3,-1,2], informTime = [0,0,162,914]Output: 1076 Constraints: 1 &lt;= n &lt;= 10^5 0 &lt;= headID &lt; n manager.length == n 0 &lt;= manager[i] &lt; n manager[headID] == -1 informTime.length == n 0 &lt;= informTime[i] &lt;= 1000 informTime[i] == 0 if employee i has no subordinates. It is guaranteed that all the employees can be informed. Solution 1注意到 manager 数组实际上给出了 children -&gt; parent的逆向关系，所以充分利用这一结构，从叶节点开始向祖先方向逆推到根节点，计算消息从根节点传递到每个叶节点的时间，最终结果就是遍历每个叶节点得到的传递时间的最大值。 123456789101112131415161718class Solution &#123;public: int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) &#123; int res = 0; for(int i=0;i&lt;n;i++)&#123; if(informTime[i] == 0)&#123; int temp_sum = 0; int t = manager[i]; while(t != -1)&#123; temp_sum += informTime[t]; t = manager[t]; &#125; res = max(res, temp_sum); &#125; &#125; return res; &#125;&#125;; 可以看出此方法的时间复杂度为 $O(n\cdot 树的深度)$ ，空间复杂度为 $O(1)$ 。 Solution 2方法 1 中包含一些重复的计算，因为不同叶节点有公共的祖先，而上面的代码对于每一条从根节点到叶节点的路径都完整计算了传递时间，这样对于公共路径部分的计算就重复了。可以用 DP 的方法来消除重复计算，建立一个备忘录数组 dp 来存储已知结果，dp[k] 表示节点 k 收到来自根节点的消息所需要的时间。状态转移方程为 dp[k] = dp[manager[k]] + informTime[manager[k]]. 123456789101112131415161718class Solution &#123;public: int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) &#123; vector&lt;int&gt; dp(n,-1); dp[headID] = 0; int res = 0; for(int i=0;i&lt;n;i++) if(!informTime[i]) res = max(res, rec(dp, i, manager, informTime)); return res; &#125; int rec(vector&lt;int&gt; &amp;dp, int k, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime)&#123; if(dp[k] != -1) return dp[k]; dp[k] = rec(dp, manager[k], manager, informTime) + informTime[manager[k]]; return dp[k]; &#125;&#125;; 此为最优解法，时间复杂度 $O(n)$ ，空间复杂度 $O(n)$ 。 Solution 3DFS 即可，注意要先建立邻接表来存储树。消息从节点 k 传递到 k 的所有子孙节点所用的时间 = informTime[k] + 消息从 k 的所有孩子的传递传递到它的所有子孙节点所用时间的最大值。 123456789101112131415class Solution &#123;public: int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) &#123; vector&lt;vector&lt;int&gt;&gt; children(n); for(int i=0;i&lt;manager.size();i++) if(manager[i] != -1) children[manager[i]].push_back(i); return dfs(children, headID, informTime); &#125; int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; children, int k, vector&lt;int&gt;&amp; informTime)&#123; int time = 0; for(int ch:children[k]) time = max(time, dfs(children, ch, informTime)); return informTime[k] + time; &#125;&#125;; 此方法时间复杂度 $O(n)$ ，但是由于要先建立邻接表，常数因子比方法 2 大；空间复杂度 $O(n)$ 。 1377. Frog Position After T Seconds Hard Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from the vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices it jumps randomly to one of them with the same probability, otherwise, when the frog can not jump to any unvisited vertex it jumps forever on the same vertex. The edges of the undirected tree are given in the array edges, where edges[i] = [fromi, toi] means that exists an edge connecting directly the vertices fromi and toi. _Return the probability that after t seconds the frog is on the vertex target._ Example 1: 123Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4Output: 0.16666666666666666 Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. Example 2: 123Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7Output: 0.3333333333333333Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1. Example 3: 12Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 20, target = 6Output: 0.16666666666666666 Constraints: 1 &lt;= n &lt;= 100 edges.length == n-1 edges[i].length == 2 1 &lt;= edges[i][0], edges[i][1] &lt;= n 1 &lt;= t &lt;= 50 1 &lt;= target &lt;= n Answers within 10^-5 of the actual value will be accepted as correct. Solution（待补充…）]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>LeetCode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-238-Product of Array Except Self]]></title>
    <url>%2F2020%2F03%2F07%2FLeetCode-238-Product-of-Array-Except-Self%2F</url>
    <content type="text"><![CDATA[238. Product of Array Except Self Medium Given an array nums of _n_ integers where _n_ > 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Example: 12Input: [1,2,3,4]Output: [24,12,8,6] Constraint: It’s guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer. Note: Please solve it without division and in O(_n_). Follow up:Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.) Solution建立两个数组 left[i] 和 right[i]，left[i]记录数组从 0 到 i 段的乘积，right[i] 记录数组从 i 到 len -1 段的乘积，结果 res[i] = left[i-1] * right[i+1] 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); vector&lt;int&gt; left(len); left[0] = nums[0]; vector&lt;int&gt; right(len); right[len-1] = nums[len-1]; for(int i=1;i&lt;len;i++) left[i] = left[i-1]*nums[i]; for(int i=len-2;i&gt;=0;i--) right[i] = right[i+1]*nums[i]; vector&lt;int&gt; res; res.push_back(right[1]); for(int i=1;i&lt;len-1;i++) res.push_back(left[i-1]*right[i+1]); res.push_back(left[len-2]); return res; &#125;&#125;; 并把循环合并一下，用两个整数 left 和 right 代替数组，可得到空间复杂度为 $O(1)$ 的代码： 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); vector&lt;int&gt; res(len,1); int left = nums[0], right = nums[len-1]; for(int i=1;i&lt;len-1;i++)&#123; res[i] *= left; left *= nums[i]; res[len-i-1] *= right; right *= nums[len-i-1]; &#125; res[0] = right; res[len-1] = left; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-239-Sliding Window Maximum]]></title>
    <url>%2F2020%2F03%2F07%2FLeetCode-239-Sliding-Window-Maximum%2F</url>
    <content type="text"><![CDATA[239. Sliding Window Maximum Hard Given an array _nums_, there is a sliding window of size _k_ which is moving from the very left of the array to the very right. You can only see the _k_ numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: 123456789101112Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7] Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Note:You may assume _k_ is always valid, 1 ≤ k ≤ input array’s size for non-empty array. Follow up:Could you solve it in linear time? Solution单调队列的典型题。单调队列是指维护一个具有单调性的队列，只能从队尾入队，但从队头和队尾两端都可以出队，一般用标准库的双端队列实现。 本题求一个范围内的最大值，因此维护一个单调递减队列，队头就是最大元。该队列的维护逻辑如下： 若队列为空，当前元素直接入队； 若队尾元素大于或等于当前元素，当前元素直接入队，这样保持了队列的单调递减特性。从题意上讲，当前元素虽然比队列中的元素都小，但是它出现的晚，随着窗口的滑动队列中比它大的元素可能不在窗口内了，当前元素有成为某个滑动窗口最大值的潜力； 若队尾元素小于当前元素，则弹出队尾元素，重复此过程直到遇到比当前元素大的或者队列变空为止，然后当前元素入队。从题意上讲，当前元素不仅比队列中的某些元素大，还出现的更晚，因此队列中那些比它小的元素没有成为某个滑动窗口最大值的的可能了，因此丢掉； 每滑动一步，检查队头元素是否还在窗口内，如果不在了就弹出队头元素。 由于要检查队头元素是否在窗口内，因此本题的单调队列保存值的索引而不是值本身，这样更方便操作。 1234567891011121314class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; deque&lt;int&gt; dq; vector&lt;int&gt; res; for(int i=0;i&lt;nums.size();i++)&#123; while(dq.size() != 0 &amp;&amp; nums[dq.back()] &lt; nums[i]) dq.pop_back(); dq.push_back(i); if(dq.front() &lt; i-k+1) dq.pop_front(); if(i &gt;= k-1) res.push_back(nums[dq.front()]); &#125; return res; &#125;&#125;; 时间复杂度为 $O(n)$。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeeoCode-240-Search a 2D Matrix II]]></title>
    <url>%2F2020%2F03%2F07%2FLeetCode-240-Search-a-2D-Matrix-II%2F</url>
    <content type="text"><![CDATA[240. Search a 2D Matrix II Medium Write an efficient algorithm that searches for a value in an _m_ x _n_ matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example: Consider the following matrix: 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] Given target = 5, return true. Given target = 20, return false. Solution注意到任何一个元素左上方的元素都比它小，右下方的元素都比它大，因此可以从最右上的元素开始搜索，遇到比待查找元素小的就向下搜索，遇到比待查找元素大的就向左搜索，直到找到该元素或者碰到边界为止。当然，从最左下的元素开始搜索也一样。 12345678910111213141516class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if(matrix.size() == 0) return false; int m = matrix.size(); int n = matrix[0].size(); int i = 0, j = n-1; while(i&lt;m &amp;&amp; j&gt;=0)&#123; if(matrix[i][j] == target) return true; else if(matrix[i][j] &gt; target) j--; else i++; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>矩阵</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-241-Different Ways to Add Parentheses]]></title>
    <url>%2F2020%2F03%2F06%2FLeetCode-241-Different-Ways-to-Add-Parentheses%2F</url>
    <content type="text"><![CDATA[241. Different Ways to Add Parentheses Medium Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 1: 12345Input: &quot;2-1-1&quot;Output: [0, 2]Explanation: ((2-1)-1) = 0 (2-(1-1)) = 2 Example 2: 12345678Input: &quot;2*3-4*5&quot;Output: [-34, -14, -10, -10, 10]Explanation: (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10 Solution 1分治法。对于每个运算符分成左右两段，递归计算做左边的所有可能取值和右边的所有可能取值，再把左右两边通过当前运算符计算的所有值存到结果集中。 123456789101112131415161718192021222324252627vector&lt;int&gt; diffWaysToCompute(string input)&#123; vector&lt;int&gt; res; for (int i = 0; i &lt; input.length(); i++) &#123; if (input[i] == '+' || input[i] == '-' || input[i] == '*') &#123; vector&lt;int&gt; res_left = diffWaysToCompute(input.substr(0, i)); vector&lt;int&gt; res_right = diffWaysToCompute(input.substr(i + 1)); for (int a : res_left) &#123; for (int b : res_right) &#123; if (input[i] == '+') res.push_back(a + b); else if (input[i] == '-') res.push_back(a - b); else res.push_back(a * b); &#125; &#125; &#125; &#125; if (res.empty()) //当前串只含数字 res.push_back(atoi(input.c_str())); return res;&#125; Solution 2DP。注意到在上面的递归中有很多重复计算，所以可以建立一个备忘录，用查表的方式避免重复计算。自顶向下递归式DP的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738vector&lt;int&gt; diffWaysToCompute(string input)&#123; unordered_map&lt;string, vector&lt;int&gt;&gt; dp; return cal(input, dp);&#125;vector&lt;int&gt; cal(string input, unordered_map&lt;string, vector&lt;int&gt;&gt; &amp;dp)&#123; if (dp.find(input) != dp.end()) return dp[input]; vector&lt;int&gt; res; for (int i = 0; i &lt; input.length(); i++) &#123; if (input[i] == '+' || input[i] == '-' || input[i] == '*') &#123; string s_left = input.substr(0, i); string s_right = input.substr(i + 1); vector&lt;int&gt; res_left = cal(s_left, dp); vector&lt;int&gt; res_right = cal(s_right, dp); for (int a : res_left) &#123; for (int b : res_right) &#123; if (input[i] == '+') res.push_back(a + b); else if (input[i] == '-') res.push_back(a - b); else res.push_back(a * b); &#125; &#125; &#125; &#125; if (res.empty()) res.push_back(atoi(input.c_str())); dp[input] = res; return res;&#125; Follow up 不用递归，自底向上的迭代式 DP 如何写？ 本题的复杂度如何分析？]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-242-Valid Anagram]]></title>
    <url>%2F2020%2F03%2F05%2FLeetCode-242-Valid-Anagram%2F</url>
    <content type="text"><![CDATA[242. Valid Anagram Easy Given two strings _s_ and _t_, write a function to determine if _t_ is an anagram of _s_. Example 1: 12Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;Output: true Example 2: 12Input: s = &quot;rat&quot;, t = &quot;car&quot;Output: false Note:You may assume the string contains only lowercase alphabets. Follow up:What if the inputs contain unicode characters? How would you adapt your solution to such case? Solution建立一个 Hash 表来计数，如果字符串中只包含小写字母，可以直接用数组来计数。 1234567891011121314class Solution &#123;public: bool isAnagram(string s, string t) &#123; if(s.length() != t.length()) return false; unordered_map&lt;char,int&gt; count; for(int i=0;i&lt;s.length();i++)&#123; count[s[i]]++; count[t[i]]--; &#125; for(auto x:count) if(x.second) return false; return true; &#125;&#125;; 注意这里利用了 map 的初始化特性，对于语句 count[s[i]];, 如果 count 中没有键 s[i]，将自动插入改该键并将相应的值初始化为 0。因此 count[s[i]]++; 无需检测 s[i] 的存在性。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>易位串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-257-Binary Tree Paths]]></title>
    <url>%2F2020%2F03%2F05%2FLeetCode-257-Binary-Tree-Paths%2F</url>
    <content type="text"><![CDATA[257. Binary Tree PathsEasy Given a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: 1234567891011Input: 1 / \2 3 \ 5Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3 Solution递归。需要3个参数：当前节点，当前节点的祖先节点组成的路径（用字符串保存），当前结果集（字符串数组）。 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; res; string ans = ""; visit(root, ans, res); return res; &#125; void visit(TreeNode* p, string ans, vector&lt;string&gt; &amp;res)&#123; if(!p) return; if(!p-&gt;left &amp;&amp; !p-&gt;right)&#123; ans += to_string(p-&gt;val); res.push_back(ans); return; &#125; ans += to_string(p-&gt;val) + "-&gt;"; if(p-&gt;left) visit(p-&gt;left, ans, res); if(p-&gt;right) visit(p-&gt;right, ans, res); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-01-两数之和-Two Sum]]></title>
    <url>%2F2019%2F11%2F22%2FLeetCode-01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-Two-Sum%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-07-整数逆序-Reverse-Integer]]></title>
    <url>%2F2019%2F10%2F16%2FLeetCode-07-%E6%95%B4%E6%95%B0%E9%80%86%E5%BA%8F-Reverse-Integer%2F</url>
    <content type="text"><![CDATA[本题算法层面无需赘述，唯一值得注意的是int溢出的检查，这可能涉及一些具体语言特性相关的知识。对C++而言，以下几个知识点可能有所帮助： 预定义常量：int最大正数INT_MAX，最小负数INT_MIN，其他类型也有类似常量定义 整数类型：一般而言 short，int，long long 分别为2字节，4字节，8字节整数，值得注意的是 long 一般与 int 相同，这一特殊情形是历史原因造成的。int，long 等类型的实际宽度与机器字长、编译器等因素均有关 代码中数字常量的默认类型：对于正数，按照 int $\rightarrow$ unsigned int $\rightarrow$ long long $\rightarrow$ unsigned long long 匹配；对于浮点数和科学计数法，一律为double型。超出最大表示范围的数字常量会报错 本题代码如下： 1234567891011121314class Solution &#123;public: int reverse(int x) &#123; long long result = 0; while (x != 0) &#123; result = result * static_cast&lt;long long&gt;(10) + static_cast&lt;long long&gt;(x % 10); x /= 10; &#125; if (result &gt; INT_MAX || result &lt; INT_MIN) return 0; else return static_cast&lt;int&gt;(result); &#125;&#125;; 循环次数为十进制整数的位数，因此复杂度为$O(\mathrm{log}_{10} n)$ 。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>整数逆序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-06-之字形转换-ZigZag-Conversion]]></title>
    <url>%2F2019%2F10%2F15%2FLeetCode-06-%E4%B9%8B%E5%AD%97%E5%BD%A2%E8%BD%AC%E6%8D%A2-ZigZag-Conversion%2F</url>
    <content type="text"><![CDATA[写几个例子找规律即可，不难发现转换后第一行和最后一行的字符在原串中的索引构成等差数列，中间行的字符在原串中的索引构成“双“等差数列（$a_1=a_0+d_1, a_2=a_1+d_2, a_3=a_2+d_1, \cdots$），找出三个公差即可。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: string convert(string s, int numRows) &#123; int L = s.length(); //行数为1或者行数不小于s的长度返回s即可 if (numRows == 1 || numRows &gt;= L) return s; string szz = ""; //保存结果 for (int i = 1; i &lt;= numRows; i++) &#123; //处理第一行和最后一行，等差数列 if(i == 1 || i == numRows) &#123; int j = i - 1; while(j &lt; L) &#123; szz += s[j]; j += 2 * (numRows - 1); &#125; &#125; //中间的行，“双”等差数列 else &#123; int j = i - 1; while (j &lt; L) &#123; szz += s[j]; j += 2 * (numRows - i); if (j &lt; L) &#123; szz += s[j]; j += 2 * (i - 1); &#125; &#125; &#125; &#125; return szz; &#125;&#125;; 每次操作均能确定目标串的一个字符，时间复杂度为$O(n)$。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>之字形转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-05.最长回文子串(LPS)]]></title>
    <url>%2F2019%2F10%2F09%2FLeetCode-05-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-LPS%2F</url>
    <content type="text"><![CDATA[先找出每个对称中心对应的LPS的长度，然后取最长的即可。注意奇数长度的串和偶数长度的串情况是不一样的，对称中心可以是元素本身也可以是元素间的间隙。若将所有间隙全部填充上同一字符（不能是串中出现的字符），便可统一为奇数情形进行处理，如 “ada” 变为 “a#d#a” ， “adaa” 变为 “a#d#a#a” 。 代码如下，这里不进行填充而是分情况讨论: 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string longestPalindrome(string s) &#123; int L = s.length(); int k = 0, len = 0; for (int i = 0; i &lt; L; i++) &#123; //考虑s[i]为对称中心 int pr1 = 1; //回文半径(包含中心) while (i - pr1 &gt;= 0 &amp;&amp; i + pr1 &lt; L &amp;&amp; s[i - pr1] == s[i + pr1]) pr1++; //考虑s[i]与s[i+1]之间的空隙为对称中心 int pr2 = 0; //回文半径 while (i - pr2 &gt;= 0 &amp;&amp; i + pr2 + 1 &lt; L &amp;&amp; s[i - pr2] == s[i + pr2 + 1]) pr2++; int len1 = 2 * (pr1 - 1) + 1; int len2 = 2 * pr2; if (max(len1, len2) &gt; len) &#123; if (len1 &gt; len2) &#123; k = i - pr1 + 1; len = len1; &#125; else &#123; k = i - pr2 + 1; len = len2; &#125; &#125; &#125; return s.substr(k, len); &#125;&#125;; 该算法时间复杂度显然为$O(n^2)$，提交LeetCode发现AC了。 实际上，有一种Manacher算法能够在$O(n)$时间内找到LPS，不过这是一种非通用算法，即该算法只能应用于解决LPS问题，因而实用价值不高。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>LPS</tag>
      </tags>
  </entry>
</search>
