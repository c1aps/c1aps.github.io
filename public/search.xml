<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode-238-Product of Array Except Self-除自身外的数组乘积]]></title>
    <url>%2F2020%2F03%2F07%2FLeetCode-238-Product-of-Array-Except-Self-%E9%99%A4%E8%87%AA%E8%BA%AB%E5%A4%96%E7%9A%84%E6%95%B0%E7%BB%84%E4%B9%98%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[238. Product of Array Except Self Medium Given an array nums of _n_ integers where _n_ > 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Example: 12Input: [1,2,3,4]Output: [24,12,8,6] Constraint: It’s guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer. Note: Please solve it without division and in O(_n_). Follow up:Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.) Solution建立两个数组 left[i] 和 right[i]，left[i]记录数组从 0 到 i 段的乘积，right[i] 记录数组从 i 到 len -1 段的乘积，结果 res[i] = left[i-1] * right[i+1] 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); vector&lt;int&gt; left(len); left[0] = nums[0]; vector&lt;int&gt; right(len); right[len-1] = nums[len-1]; for(int i=1;i&lt;len;i++) left[i] = left[i-1]*nums[i]; for(int i=len-2;i&gt;=0;i--) right[i] = right[i+1]*nums[i]; vector&lt;int&gt; res; res.push_back(right[1]); for(int i=1;i&lt;len-1;i++) res.push_back(left[i-1]*right[i+1]); res.push_back(left[len-2]); return res; &#125;&#125;; 并把循环合并一下，用两个整数 left 和 right 代替数组，可得到空间复杂度为 $O(1)$ 的代码： 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); vector&lt;int&gt; res(len,1); int left = nums[0], right = nums[len-1]; for(int i=1;i&lt;len-1;i++)&#123; res[i] *= left; left *= nums[i]; res[len-i-1] *= right; right *= nums[len-i-1]; &#125; res[0] = right; res[len-1] = left; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-239-Sliding Window Maximum-滑动窗口最大值]]></title>
    <url>%2F2020%2F03%2F07%2FLeetCode-239-Sliding-Window-Maximum-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[239. Sliding Window Maximum Hard Given an array _nums_, there is a sliding window of size _k_ which is moving from the very left of the array to the very right. You can only see the _k_ numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: 123456789101112Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7] Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Note:You may assume _k_ is always valid, 1 ≤ k ≤ input array’s size for non-empty array. Follow up:Could you solve it in linear time? Solution单调队列的典型题。单调队列是指维护一个具有单调性的队列，只能从队尾入队，但从队头和队尾两端都可以出队，一般用标准库的双端队列实现。 本题求一个范围内的最大值，因此维护一个单调递减队列，队头就是最大元。该队列的维护逻辑如下： 若队列为空，当前元素直接入队； 若队尾元素大于或等于当前元素，当前元素直接入队，这样保持了队列的单调递减特性。从题意上讲，当前元素虽然比队列中的元素都小，但是它出现的晚，随着窗口的滑动队列中比它大的元素可能不在窗口内了，当前元素有成为某个滑动窗口最大值的潜力； 若队尾元素小于当前元素，则弹出队尾元素，重复此过程直到遇到比当前元素大的或者队列变空为止，然后当前元素入队。从题意上讲，当前元素不仅比队列中的某些元素大，还出现的更晚，因此队列中那些比它小的元素没有成为某个滑动窗口最大值的的可能了，因此丢掉； 每滑动一步，检查队头元素是否还在窗口内，如果不在了就弹出队头元素。 由于要检查队头元素是否在窗口内，因此本题的单调队列保存值的索引而不是值本身，这样更方便操作。 1234567891011121314class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; deque&lt;int&gt; dq; vector&lt;int&gt; res; for(int i=0;i&lt;nums.size();i++)&#123; while(dq.size() != 0 &amp;&amp; nums[dq.back()] &lt; nums[i]) dq.pop_back(); dq.push_back(i); if(dq.front() &lt; i-k+1) dq.pop_front(); if(i &gt;= k-1) res.push_back(nums[dq.front()]); &#125; return res; &#125;&#125;; 时间复杂度为 $O(n)$。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeeoCode-240-Search a 2D Matrix II-搜索二维矩阵2]]></title>
    <url>%2F2020%2F03%2F07%2FLeetCode-240-Search-a-2D-Matrix-II-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B52%2F</url>
    <content type="text"><![CDATA[240. Search a 2D Matrix II Medium Write an efficient algorithm that searches for a value in an _m_ x _n_ matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example: Consider the following matrix: 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] Given target = 5, return true. Given target = 20, return false. Solution注意到任何一个元素左上方的元素都比它小，右下方的元素都比它大，因此可以从最右上的元素开始搜索，遇到比待查找元素小的就向下搜索，遇到比待查找元素大的就向左搜索，直到找到该元素或者碰到边界为止。当然，从最左下的元素开始搜索也一样。 12345678910111213141516class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if(matrix.size() == 0) return false; int m = matrix.size(); int n = matrix[0].size(); int i = 0, j = n-1; while(i&lt;m &amp;&amp; j&gt;=0)&#123; if(matrix[i][j] == target) return true; else if(matrix[i][j] &gt; target) j--; else i++; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>矩阵</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-241-Different Ways to Add Parentheses-不同方式加括号]]></title>
    <url>%2F2020%2F03%2F06%2FLeetCode-241-Different-Ways-to-Add-Parentheses-%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F%E5%8A%A0%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[241. Different Ways to Add Parentheses Medium Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 1: 12345Input: &quot;2-1-1&quot;Output: [0, 2]Explanation: ((2-1)-1) = 0 (2-(1-1)) = 2 Example 2: 12345678Input: &quot;2*3-4*5&quot;Output: [-34, -14, -10, -10, 10]Explanation: (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10 Solution 1分治法。对于每个运算符分成左右两段，递归计算做左边的所有可能取值和右边的所有可能取值，再把左右两边通过当前运算符计算的所有值存到结果集中。 123456789101112131415161718192021222324252627vector&lt;int&gt; diffWaysToCompute(string input)&#123; vector&lt;int&gt; res; for (int i = 0; i &lt; input.length(); i++) &#123; if (input[i] == '+' || input[i] == '-' || input[i] == '*') &#123; vector&lt;int&gt; res_left = diffWaysToCompute(input.substr(0, i)); vector&lt;int&gt; res_right = diffWaysToCompute(input.substr(i + 1)); for (int a : res_left) &#123; for (int b : res_right) &#123; if (input[i] == '+') res.push_back(a + b); else if (input[i] == '-') res.push_back(a - b); else res.push_back(a * b); &#125; &#125; &#125; &#125; if (res.empty()) //当前串只含数字 res.push_back(atoi(input.c_str())); return res;&#125; Solution 2DP。注意到在上面的递归中有很多重复计算，所以可以建立一个备忘录，用查表的方式避免重复计算。自顶向下递归式DP的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738vector&lt;int&gt; diffWaysToCompute(string input)&#123; unordered_map&lt;string, vector&lt;int&gt;&gt; dp; return cal(input, dp);&#125;vector&lt;int&gt; cal(string input, unordered_map&lt;string, vector&lt;int&gt;&gt; &amp;dp)&#123; if (dp.find(input) != dp.end()) return dp[input]; vector&lt;int&gt; res; for (int i = 0; i &lt; input.length(); i++) &#123; if (input[i] == '+' || input[i] == '-' || input[i] == '*') &#123; string s_left = input.substr(0, i); string s_right = input.substr(i + 1); vector&lt;int&gt; res_left = cal(s_left, dp); vector&lt;int&gt; res_right = cal(s_right, dp); for (int a : res_left) &#123; for (int b : res_right) &#123; if (input[i] == '+') res.push_back(a + b); else if (input[i] == '-') res.push_back(a - b); else res.push_back(a * b); &#125; &#125; &#125; &#125; if (res.empty()) res.push_back(atoi(input.c_str())); dp[input] = res; return res;&#125; Follow up 不用递归，自底向上的迭代式 DP 如何写？ 本题的复杂度如何分析？]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-242-Valid Anagram-有效易位串]]></title>
    <url>%2F2020%2F03%2F05%2FLeetCode-242-Valid-Anagram-%E6%9C%89%E6%95%88%E6%98%93%E4%BD%8D%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[242. Valid Anagram Easy Given two strings _s_ and _t_, write a function to determine if _t_ is an anagram of _s_. Example 1: 12Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;Output: true Example 2: 12Input: s = &quot;rat&quot;, t = &quot;car&quot;Output: false Note:You may assume the string contains only lowercase alphabets. Follow up:What if the inputs contain unicode characters? How would you adapt your solution to such case? Solution建立一个 Hash 表来计数，如果字符串中只包含小写字母，可以直接用数组来计数。 1234567891011121314class Solution &#123;public: bool isAnagram(string s, string t) &#123; if(s.length() != t.length()) return false; unordered_map&lt;char,int&gt; count; for(int i=0;i&lt;s.length();i++)&#123; count[s[i]]++; count[t[i]]--; &#125; for(auto x:count) if(x.second) return false; return true; &#125;&#125;; 注意这里利用了 map 的初始化特性，对于语句 count[s[i]];, 如果 count 中没有键 s[i]，将自动插入改该键并将相应的值初始化为 0。因此 count[s[i]]++; 无需检测 s[i] 的存在性。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>易位串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-257-Binary Tree Paths-二叉树路径]]></title>
    <url>%2F2020%2F03%2F05%2FLeetCode-257-Binary-Tree-Paths-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[257. Binary Tree PathsEasy Given a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: 1234567891011Input: 1 / \2 3 \ 5Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3 Solution递归。需要3个参数：当前节点，当前节点的祖先节点组成的路径（用字符串保存），当前结果集（字符串数组）。 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; res; string ans = ""; visit(root, ans, res); return res; &#125; void visit(TreeNode* p, string ans, vector&lt;string&gt; &amp;res)&#123; if(!p) return; if(!p-&gt;left &amp;&amp; !p-&gt;right)&#123; ans += to_string(p-&gt;val); res.push_back(ans); return; &#125; ans += to_string(p-&gt;val) + "-&gt;"; if(p-&gt;left) visit(p-&gt;left, ans, res); if(p-&gt;right) visit(p-&gt;right, ans, res); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-01-两数之和-Two Sum]]></title>
    <url>%2F2019%2F11%2F22%2FLeetCode-01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-Two-Sum%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-07-整数逆序-Reverse-Integer]]></title>
    <url>%2F2019%2F10%2F16%2FLeetCode-07-%E6%95%B4%E6%95%B0%E9%80%86%E5%BA%8F-Reverse-Integer%2F</url>
    <content type="text"><![CDATA[本题算法层面无需赘述，唯一值得注意的是int溢出的检查，这可能涉及一些具体语言特性相关的知识。对C++而言，以下几个知识点可能有所帮助： 预定义常量：int最大正数INT_MAX，最小负数INT_MIN，其他类型也有类似常量定义 整数类型：一般而言 short，int，long long 分别为2字节，4字节，8字节整数，值得注意的是 long 一般与 int 相同，这一特殊情形是历史原因造成的。int，long 等类型的实际宽度与机器字长、编译器等因素均有关 代码中数字常量的默认类型：对于正数，按照 int $\rightarrow$ unsigned int $\rightarrow$ long long $\rightarrow$ unsigned long long 匹配；对于浮点数和科学计数法，一律为double型。超出最大表示范围的数字常量会报错 本题代码如下： 1234567891011121314class Solution &#123;public: int reverse(int x) &#123; long long result = 0; while (x != 0) &#123; result = result * static_cast&lt;long long&gt;(10) + static_cast&lt;long long&gt;(x % 10); x /= 10; &#125; if (result &gt; INT_MAX || result &lt; INT_MIN) return 0; else return static_cast&lt;int&gt;(result); &#125;&#125;; 循环次数为十进制整数的位数，因此复杂度为$O(\mathrm{log}_{10} n)$ 。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>整数逆序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-06-之字形转换-ZigZag-Conversion]]></title>
    <url>%2F2019%2F10%2F15%2FLeetCode-06-%E4%B9%8B%E5%AD%97%E5%BD%A2%E8%BD%AC%E6%8D%A2-ZigZag-Conversion%2F</url>
    <content type="text"><![CDATA[写几个例子找规律即可，不难发现转换后第一行和最后一行的字符在原串中的索引构成等差数列，中间行的字符在原串中的索引构成“双“等差数列（$a_1=a_0+d_1, a_2=a_1+d_2, a_3=a_2+d_1, \cdots$），找出三个公差即可。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: string convert(string s, int numRows) &#123; int L = s.length(); //行数为1或者行数不小于s的长度返回s即可 if (numRows == 1 || numRows &gt;= L) return s; string szz = ""; //保存结果 for (int i = 1; i &lt;= numRows; i++) &#123; //处理第一行和最后一行，等差数列 if(i == 1 || i == numRows) &#123; int j = i - 1; while(j &lt; L) &#123; szz += s[j]; j += 2 * (numRows - 1); &#125; &#125; //中间的行，“双”等差数列 else &#123; int j = i - 1; while (j &lt; L) &#123; szz += s[j]; j += 2 * (numRows - i); if (j &lt; L) &#123; szz += s[j]; j += 2 * (i - 1); &#125; &#125; &#125; &#125; return szz; &#125;&#125;; 每次操作均能确定目标串的一个字符，时间复杂度为$O(n)$。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>之字形转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-05.最长回文子串(LPS)]]></title>
    <url>%2F2019%2F10%2F09%2FLeetCode-05-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-LPS%2F</url>
    <content type="text"><![CDATA[先找出每个对称中心对应的LPS的长度，然后取最长的即可。注意奇数长度的串和偶数长度的串情况是不一样的，对称中心可以是元素本身也可以是元素间的间隙。若将所有间隙全部填充上同一字符（不能是串中出现的字符），便可统一为奇数情形进行处理，如 “ada” 变为 “a#d#a” ， “adaa” 变为 “a#d#a#a” 。 代码如下，这里不进行填充而是分情况讨论: 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string longestPalindrome(string s) &#123; int L = s.length(); int k = 0, len = 0; for (int i = 0; i &lt; L; i++) &#123; //考虑s[i]为对称中心 int pr1 = 1; //回文半径(包含中心) while (i - pr1 &gt;= 0 &amp;&amp; i + pr1 &lt; L &amp;&amp; s[i - pr1] == s[i + pr1]) pr1++; //考虑s[i]与s[i+1]之间的空隙为对称中心 int pr2 = 0; //回文半径 while (i - pr2 &gt;= 0 &amp;&amp; i + pr2 + 1 &lt; L &amp;&amp; s[i - pr2] == s[i + pr2 + 1]) pr2++; int len1 = 2 * (pr1 - 1) + 1; int len2 = 2 * pr2; if (max(len1, len2) &gt; len) &#123; if (len1 &gt; len2) &#123; k = i - pr1 + 1; len = len1; &#125; else &#123; k = i - pr2 + 1; len = len2; &#125; &#125; &#125; return s.substr(k, len); &#125;&#125;; 该算法时间复杂度显然为$O(n^2)$，提交LeetCode发现AC了。 实际上，有一种Manacher算法能够在$O(n)$时间内找到LPS，不过这是一种非通用算法，即该算法只能应用于解决LPS问题，因而实用价值不高。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>LPS</tag>
      </tags>
  </entry>
</search>
