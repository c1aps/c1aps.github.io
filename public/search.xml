<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode Weekly Contest 179]]></title>
    <url>%2F2020%2F03%2F08%2FLeetCode-Weekly-Contest-179%2F</url>
    <content type="text"><![CDATA[LeetCode Weekly Contest 1791374. Generate a String With Characters That Have Odd Counts Easy Given an integer n, _return a string with n characters such that each character in such string occurs an odd number of times_. The returned string must contain only lowercase English letters. If there are multiples valid strings, return any of them. Example 1: 123Input: n = 4Output: &quot;pppz&quot;Explanation: &quot;pppz&quot; is a valid string since the character &apos;p&apos; occurs three times and the character &apos;z&apos; occurs once. Note that there are many other valid strings such as &quot;ohhh&quot; and &quot;love&quot;. Example 2: 123Input: n = 2Output: &quot;xy&quot;Explanation: &quot;xy&quot; is a valid string since the characters &apos;x&apos; and &apos;y&apos; occur once. Note that there are many other valid strings such as &quot;ag&quot; and &quot;ur&quot;. Example 3: 12Input: n = 7Output: &quot;holasss&quot; Constraints: 1 &lt;= n &lt;= 500 Solution若 n 是奇数，返回 n 个 a 组成的串，若 n 是偶数，返回 n-1 个 a 再加一个 b 组成的串 1234567class Solution &#123;public: string generateTheString(int n) &#123; if(n&amp;1) return string(n, 'a'); else return string(n-1, 'a') + 'b'; &#125;&#125;; 1375. Bulb Switcher III Medium There is a room with n bulbs, numbered from 1 to n, arranged in a row from left to right. Initially, all the bulbs are turned off. At moment _k_ (for _k_ from 0 to n - 1), we turn on the light[k] bulb. A bulb change color to blue only if it is on and all the previous bulbs (to the left) are turned on too. Return the number of moments in which all turned on bulbs are blue. Example 1: 123Input: light = [2,1,3,5,4]Output: 3Explanation: All bulbs turned on, are blue at the moment 1, 2 and 4. Example 2: 123Input: light = [3,2,4,1,5]Output: 2Explanation: All bulbs turned on, are blue at the moment 3, and 4 (index-0). Example 3: 1234Input: light = [4,1,2,3]Output: 1Explanation: All bulbs turned on, are blue at the moment 3 (index-0).Bulb 4th changes to blue at the moment 3. Example 4: 12Input: light = [2,1,4,3,6,5]Output: 3 Example 5: 12Input: light = [1,2,3,4,5,6]Output: 6 Constraints: n == light.length 1 &lt;= n &lt;= 5 * 10^4 light is a permutation of [1, 2, ..., n] Solution用 mx 表示当前时刻点燃的灯的最大编号，由于灯的编号为1...n ，如果 mx 恰好等于点燃的灯的数目，则灯 mx 及其之前的灯一定全部点亮了，并且 mx 之后的所有灯一定都未点亮，此时就是一个符合题意的解，计数 res 加一。 1234567891011class Solution &#123;public: int numTimesAllBlue(vector&lt;int&gt;&amp; light) &#123; int mx = 0, res = 0; for(int i=0;i&lt;light.size();i++)&#123; mx = max(mx, light[i]); if(mx == i+1) res++; &#125; return res; &#125;&#125;; 1376. Time Needed to Inform All Employees Medium A company has n employees with a unique ID for each employee from 0 to n - 1. The head of the company has is the one with headID. Each employee has one direct manager given in the manager array where manager[i] is the direct manager of the i-th employee, manager[headID] = -1. Also it’s guaranteed that the subordination relationships have a tree structure. The head of the company wants to inform all the employees of the company of an urgent piece of news. He will inform his direct subordinates and they will inform their subordinates and so on until all employees know about the urgent news. The i-th employee needs informTime[i] minutes to inform all of his direct subordinates (i.e After informTime[i] minutes, all his direct subordinates can start spreading the news). Return _the number of minutes_ needed to inform all the employees about the urgent news. Example 1: 123Input: n = 1, headID = 0, manager = [-1], informTime = [0]Output: 0Explanation: The head of the company is the only employee in the company. Example 2: 1234Input: n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]Output: 1Explanation: The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.The tree structure of the employees in the company is shown. Example 3: 123456789Input: n = 7, headID = 6, manager = [1,2,3,4,5,6,-1], informTime = [0,6,5,4,3,2,1]Output: 21Explanation: The head has id = 6. He will inform employee with id = 5 in 1 minute.The employee with id = 5 will inform the employee with id = 4 in 2 minutes.The employee with id = 4 will inform the employee with id = 3 in 3 minutes.The employee with id = 3 will inform the employee with id = 2 in 4 minutes.The employee with id = 2 will inform the employee with id = 1 in 5 minutes.The employee with id = 1 will inform the employee with id = 0 in 6 minutes.Needed time = 1 + 2 + 3 + 4 + 5 + 6 = 21. Example 4: 12345Input: n = 15, headID = 0, manager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6], informTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]Output: 3Explanation: The first minute the head will inform employees 1 and 2.The second minute they will inform employees 3, 4, 5 and 6.The third minute they will inform the rest of employees. Example 5: 12Input: n = 4, headID = 2, manager = [3,3,-1,2], informTime = [0,0,162,914]Output: 1076 Constraints: 1 &lt;= n &lt;= 10^5 0 &lt;= headID &lt; n manager.length == n 0 &lt;= manager[i] &lt; n manager[headID] == -1 informTime.length == n 0 &lt;= informTime[i] &lt;= 1000 informTime[i] == 0 if employee i has no subordinates. It is guaranteed that all the employees can be informed. Solution 1注意到 manager 数组实际上给出了 children -&gt; parent的逆向关系，所以充分利用这一结构，从叶节点开始向祖先方向逆推到根节点，计算消息从根节点传递到每个叶节点的时间，最终结果就是遍历每个叶节点得到的传递时间的最大值。 123456789101112131415161718class Solution &#123;public: int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) &#123; int res = 0; for(int i=0;i&lt;n;i++)&#123; if(informTime[i] == 0)&#123; int temp_sum = 0; int t = manager[i]; while(t != -1)&#123; temp_sum += informTime[t]; t = manager[t]; &#125; res = max(res, temp_sum); &#125; &#125; return res; &#125;&#125;; 可以看出此方法的时间复杂度为 $O(n\cdot 树的深度)$ ，空间复杂度为 $O(1)$ 。 Solution 2方法 1 中包含一些重复的计算，因为不同叶节点有公共的祖先，而上面的代码对于每一条从根节点到叶节点的路径都完整计算了传递时间，这样对于公共路径部分的计算就重复了。可以用 DP 的方法来消除重复计算，建立一个备忘录数组 dp 来存储已知结果，dp[k] 表示节点 k 收到来自根节点的消息所需要的时间。状态转移方程为 dp[k] = dp[manager[k]] + informTime[manager[k]]. 123456789101112131415161718class Solution &#123;public: int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) &#123; vector&lt;int&gt; dp(n,-1); dp[headID] = 0; int res = 0; for(int i=0;i&lt;n;i++) if(!informTime[i]) res = max(res, rec(dp, i, manager, informTime)); return res; &#125; int rec(vector&lt;int&gt; &amp;dp, int k, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime)&#123; if(dp[k] != -1) return dp[k]; dp[k] = rec(dp, manager[k], manager, informTime) + informTime[manager[k]]; return dp[k]; &#125;&#125;; 此为最优解法，时间复杂度 $O(n)$ ，空间复杂度 $O(n)$ 。 Solution 3DFS 即可，注意要先建立邻接表来存储树。消息从节点 k 传递到 k 的所有子孙节点所用的时间 = informTime[k] + 消息从 k 的所有孩子的传递传递到它的所有子孙节点所用时间的最大值。 123456789101112131415class Solution &#123;public: int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) &#123; vector&lt;vector&lt;int&gt;&gt; children(n); for(int i=0;i&lt;manager.size();i++) if(manager[i] != -1) children[manager[i]].push_back(i); return dfs(children, headID, informTime); &#125; int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; children, int k, vector&lt;int&gt;&amp; informTime)&#123; int time = 0; for(int ch:children[k]) time = max(time, dfs(children, ch, informTime)); return informTime[k] + time; &#125;&#125;; 此方法时间复杂度 $O(n)$ ，但是由于要先建立邻接表，常数因子比方法 2 大；空间复杂度 $O(n)$ 。 1377. Frog Position After T Seconds Hard Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from the vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices it jumps randomly to one of them with the same probability, otherwise, when the frog can not jump to any unvisited vertex it jumps forever on the same vertex. The edges of the undirected tree are given in the array edges, where edges[i] = [fromi, toi] means that exists an edge connecting directly the vertices fromi and toi. _Return the probability that after t seconds the frog is on the vertex target._ Example 1: 123Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4Output: 0.16666666666666666 Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. Example 2: 123Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7Output: 0.3333333333333333Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1. Example 3: 12Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 20, target = 6Output: 0.16666666666666666 Constraints: 1 &lt;= n &lt;= 100 edges.length == n-1 edges[i].length == 2 1 &lt;= edges[i][0], edges[i][1] &lt;= n 1 &lt;= t &lt;= 50 1 &lt;= target &lt;= n Answers within 10^-5 of the actual value will be accepted as correct. Solution（待补充…）]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>LeetCode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-238-Product of Array Except Self-除自身外的数组乘积]]></title>
    <url>%2F2020%2F03%2F07%2FLeetCode-238-Product-of-Array-Except-Self-%E9%99%A4%E8%87%AA%E8%BA%AB%E5%A4%96%E7%9A%84%E6%95%B0%E7%BB%84%E4%B9%98%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[238. Product of Array Except Self Medium Given an array nums of _n_ integers where _n_ > 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Example: 12Input: [1,2,3,4]Output: [24,12,8,6] Constraint: It’s guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer. Note: Please solve it without division and in O(_n_). Follow up:Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.) Solution建立两个数组 left[i] 和 right[i]，left[i]记录数组从 0 到 i 段的乘积，right[i] 记录数组从 i 到 len -1 段的乘积，结果 res[i] = left[i-1] * right[i+1] 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); vector&lt;int&gt; left(len); left[0] = nums[0]; vector&lt;int&gt; right(len); right[len-1] = nums[len-1]; for(int i=1;i&lt;len;i++) left[i] = left[i-1]*nums[i]; for(int i=len-2;i&gt;=0;i--) right[i] = right[i+1]*nums[i]; vector&lt;int&gt; res; res.push_back(right[1]); for(int i=1;i&lt;len-1;i++) res.push_back(left[i-1]*right[i+1]); res.push_back(left[len-2]); return res; &#125;&#125;; 并把循环合并一下，用两个整数 left 和 right 代替数组，可得到空间复杂度为 $O(1)$ 的代码： 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); vector&lt;int&gt; res(len,1); int left = nums[0], right = nums[len-1]; for(int i=1;i&lt;len-1;i++)&#123; res[i] *= left; left *= nums[i]; res[len-i-1] *= right; right *= nums[len-i-1]; &#125; res[0] = right; res[len-1] = left; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-239-Sliding Window Maximum-滑动窗口最大值]]></title>
    <url>%2F2020%2F03%2F07%2FLeetCode-239-Sliding-Window-Maximum-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[239. Sliding Window Maximum Hard Given an array _nums_, there is a sliding window of size _k_ which is moving from the very left of the array to the very right. You can only see the _k_ numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: 123456789101112Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7] Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Note:You may assume _k_ is always valid, 1 ≤ k ≤ input array’s size for non-empty array. Follow up:Could you solve it in linear time? Solution单调队列的典型题。单调队列是指维护一个具有单调性的队列，只能从队尾入队，但从队头和队尾两端都可以出队，一般用标准库的双端队列实现。 本题求一个范围内的最大值，因此维护一个单调递减队列，队头就是最大元。该队列的维护逻辑如下： 若队列为空，当前元素直接入队； 若队尾元素大于或等于当前元素，当前元素直接入队，这样保持了队列的单调递减特性。从题意上讲，当前元素虽然比队列中的元素都小，但是它出现的晚，随着窗口的滑动队列中比它大的元素可能不在窗口内了，当前元素有成为某个滑动窗口最大值的潜力； 若队尾元素小于当前元素，则弹出队尾元素，重复此过程直到遇到比当前元素大的或者队列变空为止，然后当前元素入队。从题意上讲，当前元素不仅比队列中的某些元素大，还出现的更晚，因此队列中那些比它小的元素没有成为某个滑动窗口最大值的的可能了，因此丢掉； 每滑动一步，检查队头元素是否还在窗口内，如果不在了就弹出队头元素。 由于要检查队头元素是否在窗口内，因此本题的单调队列保存值的索引而不是值本身，这样更方便操作。 1234567891011121314class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; deque&lt;int&gt; dq; vector&lt;int&gt; res; for(int i=0;i&lt;nums.size();i++)&#123; while(dq.size() != 0 &amp;&amp; nums[dq.back()] &lt; nums[i]) dq.pop_back(); dq.push_back(i); if(dq.front() &lt; i-k+1) dq.pop_front(); if(i &gt;= k-1) res.push_back(nums[dq.front()]); &#125; return res; &#125;&#125;; 时间复杂度为 $O(n)$。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeeoCode-240-Search a 2D Matrix II-搜索二维矩阵2]]></title>
    <url>%2F2020%2F03%2F07%2FLeetCode-240-Search-a-2D-Matrix-II-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B52%2F</url>
    <content type="text"><![CDATA[240. Search a 2D Matrix II Medium Write an efficient algorithm that searches for a value in an _m_ x _n_ matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example: Consider the following matrix: 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] Given target = 5, return true. Given target = 20, return false. Solution注意到任何一个元素左上方的元素都比它小，右下方的元素都比它大，因此可以从最右上的元素开始搜索，遇到比待查找元素小的就向下搜索，遇到比待查找元素大的就向左搜索，直到找到该元素或者碰到边界为止。当然，从最左下的元素开始搜索也一样。 12345678910111213141516class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if(matrix.size() == 0) return false; int m = matrix.size(); int n = matrix[0].size(); int i = 0, j = n-1; while(i&lt;m &amp;&amp; j&gt;=0)&#123; if(matrix[i][j] == target) return true; else if(matrix[i][j] &gt; target) j--; else i++; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>矩阵</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-241-Different Ways to Add Parentheses-不同方式加括号]]></title>
    <url>%2F2020%2F03%2F06%2FLeetCode-241-Different-Ways-to-Add-Parentheses-%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F%E5%8A%A0%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[241. Different Ways to Add Parentheses Medium Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 1: 12345Input: &quot;2-1-1&quot;Output: [0, 2]Explanation: ((2-1)-1) = 0 (2-(1-1)) = 2 Example 2: 12345678Input: &quot;2*3-4*5&quot;Output: [-34, -14, -10, -10, 10]Explanation: (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10 Solution 1分治法。对于每个运算符分成左右两段，递归计算做左边的所有可能取值和右边的所有可能取值，再把左右两边通过当前运算符计算的所有值存到结果集中。 123456789101112131415161718192021222324252627vector&lt;int&gt; diffWaysToCompute(string input)&#123; vector&lt;int&gt; res; for (int i = 0; i &lt; input.length(); i++) &#123; if (input[i] == '+' || input[i] == '-' || input[i] == '*') &#123; vector&lt;int&gt; res_left = diffWaysToCompute(input.substr(0, i)); vector&lt;int&gt; res_right = diffWaysToCompute(input.substr(i + 1)); for (int a : res_left) &#123; for (int b : res_right) &#123; if (input[i] == '+') res.push_back(a + b); else if (input[i] == '-') res.push_back(a - b); else res.push_back(a * b); &#125; &#125; &#125; &#125; if (res.empty()) //当前串只含数字 res.push_back(atoi(input.c_str())); return res;&#125; Solution 2DP。注意到在上面的递归中有很多重复计算，所以可以建立一个备忘录，用查表的方式避免重复计算。自顶向下递归式DP的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738vector&lt;int&gt; diffWaysToCompute(string input)&#123; unordered_map&lt;string, vector&lt;int&gt;&gt; dp; return cal(input, dp);&#125;vector&lt;int&gt; cal(string input, unordered_map&lt;string, vector&lt;int&gt;&gt; &amp;dp)&#123; if (dp.find(input) != dp.end()) return dp[input]; vector&lt;int&gt; res; for (int i = 0; i &lt; input.length(); i++) &#123; if (input[i] == '+' || input[i] == '-' || input[i] == '*') &#123; string s_left = input.substr(0, i); string s_right = input.substr(i + 1); vector&lt;int&gt; res_left = cal(s_left, dp); vector&lt;int&gt; res_right = cal(s_right, dp); for (int a : res_left) &#123; for (int b : res_right) &#123; if (input[i] == '+') res.push_back(a + b); else if (input[i] == '-') res.push_back(a - b); else res.push_back(a * b); &#125; &#125; &#125; &#125; if (res.empty()) res.push_back(atoi(input.c_str())); dp[input] = res; return res;&#125; Follow up 不用递归，自底向上的迭代式 DP 如何写？ 本题的复杂度如何分析？]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-242-Valid Anagram-有效易位串]]></title>
    <url>%2F2020%2F03%2F05%2FLeetCode-242-Valid-Anagram-%E6%9C%89%E6%95%88%E6%98%93%E4%BD%8D%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[242. Valid Anagram Easy Given two strings _s_ and _t_, write a function to determine if _t_ is an anagram of _s_. Example 1: 12Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;Output: true Example 2: 12Input: s = &quot;rat&quot;, t = &quot;car&quot;Output: false Note:You may assume the string contains only lowercase alphabets. Follow up:What if the inputs contain unicode characters? How would you adapt your solution to such case? Solution建立一个 Hash 表来计数，如果字符串中只包含小写字母，可以直接用数组来计数。 1234567891011121314class Solution &#123;public: bool isAnagram(string s, string t) &#123; if(s.length() != t.length()) return false; unordered_map&lt;char,int&gt; count; for(int i=0;i&lt;s.length();i++)&#123; count[s[i]]++; count[t[i]]--; &#125; for(auto x:count) if(x.second) return false; return true; &#125;&#125;; 注意这里利用了 map 的初始化特性，对于语句 count[s[i]];, 如果 count 中没有键 s[i]，将自动插入改该键并将相应的值初始化为 0。因此 count[s[i]]++; 无需检测 s[i] 的存在性。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>易位串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-257-Binary Tree Paths-二叉树路径]]></title>
    <url>%2F2020%2F03%2F05%2FLeetCode-257-Binary-Tree-Paths-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[257. Binary Tree PathsEasy Given a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: 1234567891011Input: 1 / \2 3 \ 5Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3 Solution递归。需要3个参数：当前节点，当前节点的祖先节点组成的路径（用字符串保存），当前结果集（字符串数组）。 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; res; string ans = ""; visit(root, ans, res); return res; &#125; void visit(TreeNode* p, string ans, vector&lt;string&gt; &amp;res)&#123; if(!p) return; if(!p-&gt;left &amp;&amp; !p-&gt;right)&#123; ans += to_string(p-&gt;val); res.push_back(ans); return; &#125; ans += to_string(p-&gt;val) + "-&gt;"; if(p-&gt;left) visit(p-&gt;left, ans, res); if(p-&gt;right) visit(p-&gt;right, ans, res); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-01-两数之和-Two Sum]]></title>
    <url>%2F2019%2F11%2F22%2FLeetCode-01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-Two-Sum%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-07-整数逆序-Reverse-Integer]]></title>
    <url>%2F2019%2F10%2F16%2FLeetCode-07-%E6%95%B4%E6%95%B0%E9%80%86%E5%BA%8F-Reverse-Integer%2F</url>
    <content type="text"><![CDATA[本题算法层面无需赘述，唯一值得注意的是int溢出的检查，这可能涉及一些具体语言特性相关的知识。对C++而言，以下几个知识点可能有所帮助： 预定义常量：int最大正数INT_MAX，最小负数INT_MIN，其他类型也有类似常量定义 整数类型：一般而言 short，int，long long 分别为2字节，4字节，8字节整数，值得注意的是 long 一般与 int 相同，这一特殊情形是历史原因造成的。int，long 等类型的实际宽度与机器字长、编译器等因素均有关 代码中数字常量的默认类型：对于正数，按照 int $\rightarrow$ unsigned int $\rightarrow$ long long $\rightarrow$ unsigned long long 匹配；对于浮点数和科学计数法，一律为double型。超出最大表示范围的数字常量会报错 本题代码如下： 1234567891011121314class Solution &#123;public: int reverse(int x) &#123; long long result = 0; while (x != 0) &#123; result = result * static_cast&lt;long long&gt;(10) + static_cast&lt;long long&gt;(x % 10); x /= 10; &#125; if (result &gt; INT_MAX || result &lt; INT_MIN) return 0; else return static_cast&lt;int&gt;(result); &#125;&#125;; 循环次数为十进制整数的位数，因此复杂度为$O(\mathrm{log}_{10} n)$ 。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>整数逆序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-06-之字形转换-ZigZag-Conversion]]></title>
    <url>%2F2019%2F10%2F15%2FLeetCode-06-%E4%B9%8B%E5%AD%97%E5%BD%A2%E8%BD%AC%E6%8D%A2-ZigZag-Conversion%2F</url>
    <content type="text"><![CDATA[写几个例子找规律即可，不难发现转换后第一行和最后一行的字符在原串中的索引构成等差数列，中间行的字符在原串中的索引构成“双“等差数列（$a_1=a_0+d_1, a_2=a_1+d_2, a_3=a_2+d_1, \cdots$），找出三个公差即可。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: string convert(string s, int numRows) &#123; int L = s.length(); //行数为1或者行数不小于s的长度返回s即可 if (numRows == 1 || numRows &gt;= L) return s; string szz = ""; //保存结果 for (int i = 1; i &lt;= numRows; i++) &#123; //处理第一行和最后一行，等差数列 if(i == 1 || i == numRows) &#123; int j = i - 1; while(j &lt; L) &#123; szz += s[j]; j += 2 * (numRows - 1); &#125; &#125; //中间的行，“双”等差数列 else &#123; int j = i - 1; while (j &lt; L) &#123; szz += s[j]; j += 2 * (numRows - i); if (j &lt; L) &#123; szz += s[j]; j += 2 * (i - 1); &#125; &#125; &#125; &#125; return szz; &#125;&#125;; 每次操作均能确定目标串的一个字符，时间复杂度为$O(n)$。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>之字形转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-05.最长回文子串(LPS)]]></title>
    <url>%2F2019%2F10%2F09%2FLeetCode-05-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-LPS%2F</url>
    <content type="text"><![CDATA[先找出每个对称中心对应的LPS的长度，然后取最长的即可。注意奇数长度的串和偶数长度的串情况是不一样的，对称中心可以是元素本身也可以是元素间的间隙。若将所有间隙全部填充上同一字符（不能是串中出现的字符），便可统一为奇数情形进行处理，如 “ada” 变为 “a#d#a” ， “adaa” 变为 “a#d#a#a” 。 代码如下，这里不进行填充而是分情况讨论: 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string longestPalindrome(string s) &#123; int L = s.length(); int k = 0, len = 0; for (int i = 0; i &lt; L; i++) &#123; //考虑s[i]为对称中心 int pr1 = 1; //回文半径(包含中心) while (i - pr1 &gt;= 0 &amp;&amp; i + pr1 &lt; L &amp;&amp; s[i - pr1] == s[i + pr1]) pr1++; //考虑s[i]与s[i+1]之间的空隙为对称中心 int pr2 = 0; //回文半径 while (i - pr2 &gt;= 0 &amp;&amp; i + pr2 + 1 &lt; L &amp;&amp; s[i - pr2] == s[i + pr2 + 1]) pr2++; int len1 = 2 * (pr1 - 1) + 1; int len2 = 2 * pr2; if (max(len1, len2) &gt; len) &#123; if (len1 &gt; len2) &#123; k = i - pr1 + 1; len = len1; &#125; else &#123; k = i - pr2 + 1; len = len2; &#125; &#125; &#125; return s.substr(k, len); &#125;&#125;; 该算法时间复杂度显然为$O(n^2)$，提交LeetCode发现AC了。 实际上，有一种Manacher算法能够在$O(n)$时间内找到LPS，不过这是一种非通用算法，即该算法只能应用于解决LPS问题，因而实用价值不高。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>LPS</tag>
      </tags>
  </entry>
</search>
